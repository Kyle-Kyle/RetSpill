diff --git a/net/can/bcm.c b/net/can/bcm.c
index 508f67de0..2d7c5d02e 100644
--- a/net/can/bcm.c
+++ b/net/can/bcm.c
@@ -61,13 +61,6 @@
 #include <net/sock.h>
 #include <net/net_namespace.h>
 
-/*
- * To send multiple CAN frame content within TX_SETUP or to filter
- * CAN messages with multiplex index within RX_SETUP, the number of
- * different filters is limited to 256 due to the one byte index value.
- */
-#define MAX_NFRAMES 256
-
 /* limit timers to 400 days for sending/timeouts */
 #define BCM_TIMER_SEC_MAX (400 * 24 * 60 * 60)
 
@@ -102,16 +95,16 @@ struct bcm_op {
 	struct list_head list;
 	int ifindex;
 	canid_t can_id;
-	u32 flags;
+	int flags;
 	unsigned long frames_abs, frames_filtered;
 	struct bcm_timeval ival1, ival2;
 	struct hrtimer timer, thrtimer;
 	ktime_t rx_stamp, kt_ival1, kt_ival2, kt_lastmsg;
 	int rx_ifindex;
 	int cfsiz;
-	u32 count;
-	u32 nframes;
-	u32 currframe;
+	int count;
+	int nframes;
+	int currframe;
 	/* void pointers to arrays of struct can[fd]_frame */
 	void *frames;
 	void *last_frames;
@@ -216,9 +209,9 @@ static int bcm_proc_show(struct seq_file *m, void *v)
 			   bcm_proc_getifname(net, ifname, op->ifindex));
 
 		if (op->flags & CAN_FD_FRAME)
-			seq_printf(m, "(%u)", op->nframes);
+			seq_printf(m, "(%d)", op->nframes);
 		else
-			seq_printf(m, "[%u]", op->nframes);
+			seq_printf(m, "[%d]", op->nframes);
 
 		seq_printf(m, "%c ", (op->flags & RX_CHECK_DLC) ? 'd' : ' ');
 
@@ -245,9 +238,9 @@ static int bcm_proc_show(struct seq_file *m, void *v)
 			   bcm_proc_getifname(net, ifname, op->ifindex));
 
 		if (op->flags & CAN_FD_FRAME)
-			seq_printf(m, "(%u) ", op->nframes);
+			seq_printf(m, "(%d) ", op->nframes);
 		else
-			seq_printf(m, "[%u] ", op->nframes);
+			seq_printf(m, "[%d] ", op->nframes);
 
 		if (op->kt_ival1)
 			seq_printf(m, "t1=%lld ",
@@ -321,7 +314,7 @@ static void bcm_send_to_user(struct bcm_op *op, struct bcm_msg_head *head,
 	struct canfd_frame *firstframe;
 	struct sockaddr_can *addr;
 	struct sock *sk = op->sk;
-	unsigned int datalen = head->nframes * op->cfsiz;
+	int datalen = head->nframes * op->cfsiz;
 	int err;
 
 	skb = alloc_skb(sizeof(*head) + datalen, gfp_any());
@@ -505,7 +498,7 @@ static void bcm_rx_update_and_send(struct bcm_op *op,
  * bcm_rx_cmp_to_index - (bit)compares the currently received data to formerly
  *                       received data stored in op->last_frames[]
  */
-static void bcm_rx_cmp_to_index(struct bcm_op *op, unsigned int index,
+static void bcm_rx_cmp_to_index(struct bcm_op *op, int index,
 				const struct canfd_frame *rxdata)
 {
 	struct canfd_frame *cf = op->frames + op->cfsiz * index;
@@ -602,7 +595,7 @@ static int bcm_rx_thr_flush(struct bcm_op *op)
 	int updated = 0;
 
 	if (op->nframes > 1) {
-		unsigned int i;
+		int i;
 
 		/* for MUX filter we start at index 1 */
 		for (i = 1; i < op->nframes; i++)
@@ -641,7 +634,7 @@ static void bcm_rx_handler(struct sk_buff *skb, void *data)
 {
 	struct bcm_op *op = (struct bcm_op *)data;
 	const struct canfd_frame *rxframe = (struct canfd_frame *)skb->data;
-	unsigned int i;
+	int i;
 
 	if (op->can_id != rxframe->can_id)
 		return;
@@ -846,15 +839,14 @@ static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
 	struct bcm_sock *bo = bcm_sk(sk);
 	struct bcm_op *op;
 	struct canfd_frame *cf;
-	unsigned int i;
-	int err;
+	int i, err;
 
 	/* we need a real device to send frames */
 	if (!ifindex)
 		return -ENODEV;
 
 	/* check nframes boundaries - we need at least one CAN frame */
-	if (msg_head->nframes < 1 || msg_head->nframes > MAX_NFRAMES)
+	if (msg_head->nframes < 1)
 		return -EINVAL;
 
 	/* check timeval limitations */
@@ -1030,10 +1022,6 @@ static int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
 		msg_head->nframes = 0;
 	}
 
-	/* the first element contains the mux-mask => MAX_NFRAMES + 1  */
-	if (msg_head->nframes > MAX_NFRAMES + 1)
-		return -EINVAL;
-
 	if ((msg_head->flags & RX_RTR_FRAME) &&
 	    ((msg_head->nframes != 1) ||
 	     (!(msg_head->can_id & CAN_RTR_FLAG))))
@@ -1058,8 +1046,7 @@ static int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
 
 		if (msg_head->nframes) {
 			/* update CAN frames content */
-			err = memcpy_from_msg(op->frames, msg,
-					      msg_head->nframes * op->cfsiz);
+			err = copy_from_iter(op->frames, msg_head->nframes * op->cfsiz, &msg->msg_iter) == msg_head->nframes * op->cfsiz ? 0 : -EFAULT;
 			if (err < 0)
 				return err;
 
@@ -1086,18 +1073,16 @@ static int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
 
 		if (msg_head->nframes > 1) {
 			/* create array for CAN frames and copy the data */
-			op->frames = kmalloc_array(msg_head->nframes,
-						   op->cfsiz,
-						   GFP_KERNEL);
+			op->frames = kmalloc(msg_head->nframes * op->cfsiz,
+					GFP_KERNEL);
 			if (!op->frames) {
 				kfree(op);
 				return -ENOMEM;
 			}
 
 			/* create and init array for received CAN frames */
-			op->last_frames = kcalloc(msg_head->nframes,
-						  op->cfsiz,
-						  GFP_KERNEL);
+			op->last_frames = kzalloc(msg_head->nframes * op->cfsiz,
+					GFP_KERNEL);
 			if (!op->last_frames) {
 				kfree(op->frames);
 				kfree(op);
